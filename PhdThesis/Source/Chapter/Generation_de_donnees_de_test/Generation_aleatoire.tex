\section{Génération pseudo-aléatoire et rejet}
\label{section:data:random}

Commençons par le processus de génération des données dans Praspel, qui se
déroule basiquement en 3~étapes~:

\begin{enumerate}

\item sélection d'une variable~;

\item génération, validation et assignation d'une donnée à cette variable~;

\item sélection de la variable suivante.

\end{enumerate}

Les variables qui nous intéressent sont déclarées dans les préconditions ainsi
que dans les invariants. Ces derniers seront traités dans la
partie~\ref{section:data:objects}. Rappelons-nous qu'une précondition est
constituée de déclarations, de prédicats et de contraintes (voir la
figure~\ref{figure:language:grammar_part2}). Lors d'une génération de données,
nous allons commencer par traiter les déclarations. Nous allons choisir une
variable $v$ dans la liste des variables $V$, les unes après les autres.
L'ordre des variables est décroissant selon le nombre de contraintes portées~:
la variable avec le plus de contraintes sera la première de la liste.

Une variable porte une disjonction de domaines réalistes, soit $n$ domaine
réalistes~:
%
$$\code{i: $t_1$(\dots) or \dots or $t_n$(\dots)}$$
%
Nous allons choisir pseudo-aléatoirement le domaine réaliste $t_c$ avec $c \in
[1, n]$. Cette étape est représentée par l'état \code{pick} dans la
figure~\ref{figure:data:process}.
%
\begin{figure}

\fig{8.5cm}{!}{Generation_process.tex}

\caption{\label{figure:data:process} Processus de génération des données pour
une liste de variables $V$. Les annotations sur les transitions représentent des
gardes pour activer la transition.}

\end{figure}
%
Sur ce domaine réaliste, nous allons utiliser sa propriété de générabilité, soit
appeler sa méthode \code{sample}. Au sein d'un domaine réaliste, quand une
donnée est générée, elle est aussitôt confrontée à sa propriété de
prédicabilité, soit sa méthode \code{predicate}, afin de savoir si la donnée est
valide ou non. Si la précondition a des prédicats (avec la construction
\apred{p}), alors ces derniers seront évalués avec les données fraîchement
générées. Si un prédicat a besoin de plusieurs variables, alors son évaluation
sera repoussée à plus tard.

Si pendant ce cycle, la propriété de prédicabilité d'un domaine réaliste ou
qu'un prédicat invalide une donnée, nous parlons de {\strong rejet}. Et suite à
un rejet, une donnée est re-générée. Un nombre maximum $\tau_\mathrm{max}$ de
re-générations $\tau$ est fixé afin d'éviter des générations et des rejets en
boucle. À chaque génération, $\tau$ est incrémenté de 1. La valeur de
$\tau_\mathrm{max}$ est paramétrable. \\

Mais il n'y a pas que le choix d'un domaine réaliste parmi une disjonction qui
est pseudo-aléatoire. Par défaut, un domaine réaliste génère une donnée de
manière pseudo-aléatoire.  Si nous écrivons \code{boundinteger(7, 42)}, alors un
entier de l'intervalle 7 à 42 sera généré pseudo-aléatoirement. Nous avons
précisé dans la partie~\ref{subsection:language:realdom:implementation} qu'une
méthode \code{sample} d'un domaine réaliste reçoit un générateur numérique en
argument. Le seul générateur actuel est pseudo-aléatoire, basé sur l'algorithme
de Mersenne Twister~\acite{MatsumotoN98}. Il permet de générer des entiers et
des réels. Un exemple d'utilisation a été montré dans la
figure~\ref{figure:language:boundinteger}.

C'est aussi cette méthodologie qu'utilise le domaine réaliste \code{String} pour
générer des chaînes de caractères. Cette approche pseudo-aléatoire pose
rapidement des problèmes. Le nombre de valeurs possibles pour \code{string('a',
'z', 10)}, c'est~à~dire une chaîne de caractères ne contenant que les caractères
de \code{a} à \code{z} en minuscules d'une longueur de 10, est de $26^{10}$,
soit environ $1.412e^{14}$ données. La probabilité qu'une de ces données détecte
une erreur dans notre programme est extrairement faible. C'est un problème
inhérent à l'approche pseudo-aléatoire. Cependant, l'ensemble des valeurs
générables peut être considérablement réduit si la donnée est mieux spécifiée
(représentée). Plus la donnée pourra être spécifiée avec précisions, plus nous
devrions être capables de générer des données pertinentes, c'est~à~dire capables
de détecter des erreurs. \\

Dans les parties suivantes, nous allons nous intéresser à mieux spécifier et
mieux générer des tableaux, des chaînes caractères et des objets.
