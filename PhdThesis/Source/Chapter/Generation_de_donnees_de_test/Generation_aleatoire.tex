\section{Génération pseudo-aléatoire et rejet}
\label{section:data:random}

Cette section explique le processus de génération des données dans Praspel, qui
se déroule basiquement en 3~étapes~:
\begin{enumerate}

\item sélection d'une variable~;

\item génération, validation et assignation d'une donnée à cette variable~;

\item sélection de la variable suivante.

\end{enumerate}

Les variables qui nous intéressent sont déclarées dans les préconditions ainsi
que dans les invariants. Ces derniers seront traités dans la
Section~\ref{section:data:objects}. Rappelons-nous qu'une précondition est
constituée de déclarations, de prédicats et de contraintes (voir la
Figure~\ref{figure:language:grammar_part2}). Lors d'une génération de données,
nous allons commencer par traiter les déclarations. Nous allons choisir les
variables les unes après les autres. L'ordre de sélection des variables dépend
du nombre de contraintes associées~: plus une variable a des contraintes, plutôt
elle sera sélectionnée. Pour chaque variable, nous allons choisir
pseudo-aléatoirement un domaine réaliste~:

$$\code{i: $t_1$(\dots) or \dots or $t_n$(\dots)}$$

Nous allons choisir le domaine réaliste $t_c(\dots)$ pour ...

Sur ce domaine réaliste, nous allons utiliser sa propriété de générabilité, soit
appeler sa méthode \code{sample}, comme illustré dans la
Figure~\ref{figure:data:process}.
%
\begin{figure}

\fig{6.5cm}{!}{Generation_process.tex}

\caption{\label{figure:data:process} Processus de génération d'une donnée dans
les domaines réalistes.}

\end{figure}
%
Au sein d'un domaine réaliste, quand une donnée est générée, elle est aussitôt
confrontée à sa propriété de prédicabilité, soit sa méthode \code{predicate},
afin de savoir si la donnée est valide ou non. Toutes les variables ont
maintenant des valeurs.  Si la précondition a des prédicats (avec la
construction \apred{p}), alors ces derniers seront évalués avec les données
fraîchement générées.

Si pendant ce cycle, la propriété de prédicabilité d'un domaine réaliste ou
qu'un prédicat invalide une donnée, nous parlons de {\strong rejet}. Et suite à
un rejet, une donnée est regénérée. Un nombre maximum de re-génération est fixé
afin d'éviter des générations et des rejets en boucle. \\

Par défaut, un domaine réaliste génère une donnée de manière pseudo-aléatoire.
Si nous écrivons \code{boundinteger(7, 42)}, alors un entier de l'intervalle 7 à
42 sera généré pseudo-aléatoirement. Nous avons précisé dans la
Section~\ref{subsection:language:realdom:implementation} qu'une méthode
\code{sample} d'un domaine réaliste reçoit un générateur numérique en argument.
Le seul générateur actuel est pseudo-aléatoire, basé sur l'algorithme de
Mersenne Twister~\acite{MatsumotoN98}. Il permet de générer des entiers et des
réels. Un exemple d'utilisation a été montré dans la
Figure~\ref{figure:language:boundinteger}.

C'est aussi cette méthodologie qu'utilise le domaine réaliste \code{String} pour
générer des chaînes de caractères. Cette approche pseudo-aléatoire pose
rapidement des problèmes. Le nombre de valeurs possibles pour \code{string('a',
'z', 10)}, c'est~à~dire une chaîne de caractères ne contenant que les caractères
de \code{a} à \code{z} en minuscules, d'une longueur de 10, est de $26^{10}$,
soit environ $1.412e^{14}$ données. La probabilité qu'une de ces données détecte
une erreur dans notre programme est extrairement faible. C'est un problème
inhérent à l'approche pseudo-aléatoire. Toutefois, l'ensemble des valeurs
générables peut être considérablement réduit si la donnée est mieux spécifiée
(représentée). Plus la donnée pourra être spécifiée avec précisions, plus nous
devrions être capable de générer des données pertinentes, capable de détecter
des erreurs.
