\section{Définitions}
\label{section:test:definitions}

Un {\strong chemin} est une séquence de transitions consécutives séparées par
des points. Deux transitions $(v, \alpha, w)$ et $(x, \beta, y)$ sont
consécutives si et seulement si $w = x$. Nous disons qu'un sommet $v$ {\strong
est dans} le chemin $p$ si et seulement si le chemin $p$ contient une transition
$(v, \alpha, w)$ ou $(w, \alpha, v)$.

Nous associons deux sortes de chemins à un contrat $G = (V, D, i, N, E, U)$. Une
{\strong route} de $G$ est un chemin dont les transitions sont dans $D$. À
présent, soit $r$ une route de $G$, $e$ une expression et $H = (V_H, D_H, i_H,
n_H)$ le graphe de l'expression. Nous remplaçons toutes les transitions $(v, e,
w)$ dans $r$ par le chemin $(v, \varepsilon, i_H) \cdot q \cdot (n_H,
\varepsilon, w)$ où $q$ est un chemin de $i_H$ à $n_H$ du graphe $H$. Le
résultat est appelé un {\strong sentier} de $r$. Un sentier d'un graphe de
contrat $G$ est n'importe quel sentier obtenu depuis une route de $G$.

Un {\strong test unitaire} pour une méthode PHP \code{f} est un ensemble de
données (appelées entrées), qui fixent les valeurs pour les
arguments de \code{f}. Un {\strong cas de test} est une paire $(s, t)$ composée
d'un état $s$ (le contexte dans lequel est exécuté le test) et un test unitaire
$t$. Pour construire l'état $s$, nous avons deux approches~:
%
\begin{enumerate}

\item créer un objet et invoquer ses méthodes afin de changer son état~; ou

\item instrumenter le code pour détourner l'encapsulation et définir l'état de
l'objet directement.

\end{enumerate}
%
Une {\strong suite de tests} est un ensemble de cas de test.

Quand nous exécutons un cas de test, nous sommes capable d'y associer des
chemins du graphe de contrat $G$, appelés chemins {\strong activés par} le cas
de test, démarrant depuis l'état initial de $G(\code{f})$ et terminant dans un
de ses états finaux (soit normaux soit exceptionels).

Nous représentons par $s'$ l'état après l'exécution du test, par $r$ la valeur
retournée par la méthode \code{f} et par $e$ l'exception levée le cas échéant.
Remarquons que si la méthode lève une exception, alors $r$ est indéfinie. À
l'inverse, si la méthode termine normalement (c'est~à~dire sans lever
d'exception), $e$ est considérée comme indéfinie.

Afin de définir quels sont les chemins (autant les routes que les sentiers) d'un
contrat qui sont activés par un cas de test $(s, t)$, nous explorons le contrat
$G(\code{f})$ et nous collectons les chemins en évaluant les étiquettes des
transitions tout en respectant le test $t$~:
%
\begin{itemize}

\item si la transition est étiquetée par une expression $R$ (respectivement
$I$) provenant d'une précondition (respectivement d'un invariant évalué dans le
pré-état), la transition est activée si et seulement si $R$ (respectivement $I$)
est vraie dans le pré-état $s$~;

\item si la transition est étiquetée par une expression $E$ provenant d'une
postcondition (normale ou exceptionnelle), la transition est activée si et
seulement si $E$ est vraie, quand \aresult est remplacée par la valeur retournée
$r$, les sous-expressions \aold{\empty} sont remplacées par leur valeur dans le
pré-état $s$, et les autres sous-expressions sont évaluées dans le post-état
$s'$~;

\item si la transition est étiquetée par une expression $I$ provenant d'un
invariant évalué dans le post-état, la transition est activée si et seulement si
$I$ est vraie dans le post-état $s'$~;

\item si la transition est étiquetée par une déclaration de domaines réalistes
\code{$i$: $d$}, la transition est activée si et seulement si la valeur courante
de $i \in t$ appartient à un des domaines réalistes dans la disjonction $d$
(grâce à la caractéristique de prédicabilité). Quand cette déclaration provient
d'une précondition (c'est~à~dire dans un graphe d'expression d'une
précondition), la valeur de $i$ est choisie dans le pré-état $s$ du test si $i$
est un attribut de classe, ou dans les arguments de la méthode si $i$ est un
argument de la méthode. Quand la déclaration est exprimée dans une postcondition
(normale ou exceptionnelle), la valeur de $i$ est choisie dans le post-état
$s'$~;

\item si la transition est étiquetée par un prédicat, la transition est activée
si et seulement le prédicat est satisfait avec l'état courant du système ($s$
dans le cas d'une précondition, $s'$ pour un prédicat \inenglish{before-after},
c'est~à~dire contenu dans une postcondition, dont les expressions \aold{\empty}
sont évaluées dans le pré-état $s$)~;

\item si la transition est étiquetée par un \grule{exception-identifier} $T_C$,
alors la transition est activée si et seulement si l'exception levée $e$ n'est
pas indéfinie et est une instance de $T_C$.

\end{itemize}

\begin{example}[Activer plusieurs chemins avec un même cas de tests]

Dans la figure~\ref{figure:test:throwable_graph}, nous voyons qu'il est possible
d'activer plusieurs chemins en même temps, quand $T_{C_1}$ étend $T_{C_2}$ et
qu'une exception de classe $T_{C_1}$ est levée. Nous représentons par
$R_\code{f}(S)$ l'ensemble des routes de $G(\code{f})$ activées par une suite de
test $S$. Similairement, nous représentons par $T_\code{f}(S)$ l'ensemble des
sentiers de $G(\code{f})$ activés par une suite de test $S$ et traversant des
graphes d'expression imbriquées dans $G(\code{f})$.

\end{example}

Les exemples suivants sont basés sur le contrat de la
figure~\ref{figure:test:irc} pour la méthode \code{compute} avec deux arguments:
\code{server} qui doit être une classe de type
\code{\bslash{}Irc\bslash{}Server} et \code{buffer} qui doit contenir un message
IRC.
%
\begin{figure}

\begin{bigpre}
/** \\
 * \arequires server: class('\(\bslash\)Irc\(\bslash\)Server'); \\
 * \abehavior message \{ \\
 *     \arequires buffer: /^privmessage .+/ or /^message .+/; \\
 *     \aensures  \aresult: 1..; \\
 * \} \\
 * \abehavior ping \{ \\
 *     \arequires buffer: /^ping\$/ and \\
 *               \(\bslash\)pred('\$server->bufferState   >= 0 or \\
 *                      network\_buffer\_state() >  0'); \\
 *     \aensures  \aresult: 1..; \\
 * \} \\
 * \adefault \{ \\
 *     \athrowable \(\bslash\)Irc\(\bslash\)Exception\(\bslash\)MalformedMessage e \\
 *                    with e->code: 400..491; \\
 * \} \\
 */ \\
public static function compute ( \$server, \$buffer ) \{ … \}
\end{bigpre}

\caption{\label{figure:test:irc} Exemple d'un contrat et d'une méthode
manipulant un flux IRC.}

\end{figure}
%
Nous avons deux comportements, un pour un message privé ou public (représenté
par une expression régulière à travers le domaine réaliste \code{regex} sous sa
forme simplifiée) et un pour un «~ping~». Dans le dernier comportement, la
précondition a un prédicat pour spécifier que le réseau est dans un état
spécifique. Enfin, le comportement par défaut spécifie qu'une exception de type
\code{\bslash{}Irc\bslash{}Exception\bslash{}MalformedMessage} doit être levée
si le tampon n'est ni un message ni un ping. De plus, le code d'une exception
doit être un entier entre 400 et 491.

