\section{Praspel}
\label{section:tools:praspel}

Cette partie est consacrée à présenter l'implémentation et l'outillage de
Praspel. Tout d'abord, la partie~\ref{subsection:tools:interpretation} présente
comment le langage est analysé. Ensuite, la partie~\ref{subsection:tools:model}
présente l'architecture de Praspel et son modèle objet, la pièce centrale,
suivie des partie~\ref{subsection:tools:compilation}
et~\ref{subsection:tools:disassembler} qui présentent respectivement comment
exporter ou importer le modèle et comment le désassembler. Puis, la
partie~\ref{subsection:tools:evaluation} présente comment l'évaluer. Enfin,
comme Praspel est un langage de spécification destiné à PHP construit de façon
modulaire et extensible, pour faciliter son développement et sa maintenance,
nous avons choisi de nous appuyer sur le projet Hoa, présenté dans la
partie~\ref{subsection:tools:hoa}.

\begin{figure}

\drawfig{10.4cm}{!}{node distance=3cm}{

    \node (model) [rectangle, minimum height=3cm] {
        modèle objet

        \raisebox{0cm}[1.5cm]{
            \begin{tikzpicture}[node distance=4cm]
            \node [state, scale=.15] (foo1) {};
            \node [state, scale=.15, below left of=foo1] (foo2) {};
            \node [state, scale=.15, below right of=foo1] (foo3) {};
            \node [state, scale=.15, below left of=foo3] (foo4) {};
            \node [state, scale=.15, below right of=foo3] (foo5) {};
            \draw [thick] (foo1) -- (foo2) (foo1) -- (foo3) (foo3) -- (foo4) (foo3) -- (foo5);
            \end{tikzpicture}
        }
    };
    \node (language) [left of=model] {
        \tikzref{boxtoolsomA} langage
    };
    \node (php) [right of=model] {
        PHP
    };

    \draw [arrow] (language.north)
                      -- node[auto] {\small analyses}
                      ++(0, 1.68)
                      -| ([xshift=-5pt] model.north);
    \draw [arrow] ([xshift=+5pt] model.north)
                      --
                      ++(0, 0.5)
                      -| node[auto, yshift=-.9cm] {\small exportation} (php.north);
    \draw [arrow] (php.south)
                      -- node[auto] {\small importation}
                      ++(0, -1.72)
                      -| ([xshift=+5pt] model.south);
    \draw [arrow] ([xshift=-5pt] model.south)
                      --
                      ++(0, -0.5)
                      -| node[auto, yshift=.8cm] {\small désassemblage} (language.south);

    % does not work in annotations, don't know why…
    \node (Mc) [above of=model, node distance=3.5cm] {\circled{M}};
    \draw [mywavyarrow] (model) -- (Mc);
}
%
\begin{tikzannotation}
    \node (pc) [yshift=-.1cm] at (boxtoolsomA -| boxtoolsomA) {};
    \node (Pc) [left of=pc, node distance=1.8cm] {\circled{P}};
    \draw [mywavyarrow] (Pc) -- (pc);
\end{tikzannotation}

\caption{\label{figure:tools:praspel} Fonctionnement schématique de Praspel.}

\end{figure}

Praspel existe sous différentes formes. Nous les expliquons en nous appyant sur
la figure~\ref{figure:tools:praspel} qui montre l'agencement de ces différentes
formes et le passage de l'une vers l'autre~:
%
\begin{itemize}

\item le langage est la forme textuelle de Praspel, provenant des commentaires
des méthodes. Il est défini par la grammaire dans la
section~\ref{section:language:praspel}. En utilisant des analyseurs, le langage
est transformé en modèle objet~;

\item le modèle objet est la pièce centrale de Praspel~: c'est un ensemble
d'objets en mémoire réprésentant chaque partie du langage (clause, variable,
opérateur etc.). Tous ces objets sont imbriqués et forme une structure qui
s'apparente à un arbre~;

\item le modèle objet peut être exporté sous forme de code PHP qui, quand il est
exécuté, reconstruit en mémoire le modèle objet depuis lequel il a été généré~;

\item le désassemblage permet de transformer le modèle objet sous sa forme
textuelle.

\end{itemize}
%
Les parties suivantes détaillent ses différentes étapes.

\subsection{Analyses}
\label{subsection:tools:interpretation}

À l'aide de la grammaire de Praspel, définie dans la
section~\ref{section:language:praspel}, exprimée avec le langage PP (voir
l'annexe~\ref{appendices:grammar_of_praspel}) et un compilateur, défini dans les
sections~\ref{subsection:data:pp} et \ref{subsection:data:compiler-compiler},
l'AST du contrat analysé sera produit. Cet AST sera ensuite visité afin de
construire le modèle objet. Pour y arriver, nous avons deux façons de faire. La
première détaille toutes les étapes, à savoir l'utilisation du compilateur pour
produire un AST, puis l'appel d'un visiteur pour construire le modèle objet~;
ainsi~:
%
\begin{pre}
\$compiler    = Hoa\bslash{}Compiler\bslash{}Llk::load( \\
    new Hoa\bslash{}File\bslash{}Read('hoa://Library/Praspel/Grammar.pp') \\
);                                          \tikzref{codetoolspraspel} \\
\$ast         = \$compiler->parse('@requires i: 7..42;'); \\
\$interpreter = new Hoa\bslash{}Praspel\bslash{}Visitor\bslash{}Interpreter(); \\
\tikzref{codetoolsom}\$model       = \$interpreter->visit(\$ast);
\end{pre}
%
\begin{tikzannotation}
    \node (Pc) [right of=codetoolspraspel, node distance=3cm, yshift=-.5cm] {\circled{P}};
    \draw [mywavyarrow] (Pc) to[out=135, in=45, distance=.5cm] (codetoolspraspel.south);

    \node (Mc) [above of=codetoolsom, node distance=1.4cm, xshift=-.6cm] {\circled{M}};
    \draw [mywavyarrow] (codetoolsom.north west) to[out=180, in=-90] (Mc);
\end{tikzannotation}

La variable \code{\$compiler} contient le compilateur chargé depuis une
grammaire. La variable \code{\$ast} contient l'AST produit par l'analyse
lexicale et l'analyse syntaxique d'une chaîne de caractères représentant du code
Praspel. Ces analyses sont exécutées en appelant la méthode \code{parse} sur le
compilateur. Ensuite, nous instancions un visiteur dans la variable
\code{\$interpreter} qui va visiter, grâce à la méthode \code{viist}, l'AST pour
le transformer en modèle objet.

La seconde façon de faire consiste à utiliser un raccourci qui est la méthode
(statique) \code{interprete}~; ainsi~:
%
\begin{pre}
\$model = Hoa\bslash{}Praspel::interprete('@requires i: 7..42;');
\end{pre}
%
produira le même résultat.

Durant la production de l'AST, les erreurs {\strong lexicales} et {\strong
syntaxiques} seront détectées. Et durant la production du modèle objet, les
erreurs {\strong sémantiques} seront détectées.

\subsection{Modèle objet}
\label{subsection:tools:model}

\subsection{Exportation et importation}
\label{subsection:tools:compilation}

Le modèle objet peut être exporté de la mémoire vers un fichier sous la forme
de code PHP. Quand ce code PHP est exécuté, c'est une importation car il
construit en mémoire le modèle objet depuis lequel il a été généré.
Cela permet de «~sauvegarder~» le modèle en évitant la phase
des analyses qui peuvent être coûteuses dans certaines situations. Ainsi, à
partir d'un modèle contenu dans la variable \code{\$model} et d'un visiteur,
nous allons produire du code PHP que nous allons afficher~:
%
\begin{pre}
\$compiler = new Hoa\bslash{}Praspel\bslash{}Visitor\bslash{}Compiler(); \\
echo \$compiler->visit(\$mo\tikzref{codetoolsom}del);
\end{pre}
%
\begin{tikzannotation}
    \node (Mc) [right of=codetoolsom, node distance=1.6cm] {\circled{M}};
    \draw [mywavyarrow] (Mc) to[out=-150, in=-70, distance=.2cm] (codetoolsom);
\end{tikzannotation}

Cet exemple produira le code PHP suivant~:
%
\begin{pre}
\$praspel = new \bslash{}Hoa\bslash{}Praspel\bslash{}Model\bslash{}Specification(); \\
 \\
\$requires = \$praspel->getClause('requires'); \\
\$requires['i']->in = realdom()->boundinteger(7, 42);
\end{pre}
%
qui permet de construire le modèle objet contenu dans \code{\$model},
c'est~à~dire que la valeur de la variable \code{\$model} est strictement égale à
la valeur de la variable \code{\$praspel}. Cet exemple nous permet également
d'avoir un aperçu de l'API du modèle objet~: elle se veut le plus simple et
compréhensible possible. Une spécification est instanciée. Sur cette
spécification, la clause \arequires est obtenue pour y déclarer une variable
\code{i} dont les valeurs sont décrites par (ou présentent dans, \code{->in}) la
disjonction de domaines réalistes, créée à l'aide de la fonction \code{realdom}.
Cette fonction se comporte comme une macro.

\subsection{Désassemblage}
\label{subsection:tools:disassembler}

Le désassemblage permet de passer le modèle objet en mémoire sous sa forme
textuelle. C'est l'opération inverse des analyses de la
section~\ref{subsection:tools:interpretation}. Il permet par exemple d'indiquer
des erreurs avec précisions sous la forme originale de Praspel. C'est tout à
fait comparable à un \inenglish{pretty-printer}. Ainsi~:
%
\begin{pre}
\$disassembler = new Hoa\bslash{}Praspel\bslash{}Visitor\bslash{}Praspel(); \\
echo \$disassembler->visit(\$mo\tikzref{codetoolsom}del);
\end{pre}
%
\begin{tikzannotation}
    \node (Mc) [right of=codetoolsom, node distance=1.6cm] {\circled{M}};
    \draw [mywavyarrow] (Mc) to[out=-150, in=-70, distance=.2cm] (codetoolsom);
\end{tikzannotation}

Encore une fois, nous instancions une visiteur dans la variable
\code{\$disas\-sem\-bler} pour ensuite visiter le modèle objet. Cette exemple
produira le résultat suivant~:
%
\begin{pre}
@requires i: boundinteger(7, 42);
\end{pre}
%
Notons que le sucre syntaxique \code{7..42} a disparu.

Ce dernier processus, complété des précédents, nous permet de passer d'une
représentation vers n'importe quelle autre représentation de Praspel~: soit
textuelle, soit objet, soit PHP.

\subsection{Évaluation avec un \inenglish{Runtime Assertion Checker}}
\label{subsection:tools:evaluation}

\begin{figure}

\centering

\begin{tikzbox}{boxtoolsrac}{xshift=1.1cm}
    \fig{11cm}{!}{RAC.tex}
\end{tikzbox}
%
\begin{tikzannotation}
    \node (mc) [xshift=.2cm, yshift=-.97cm] at (boxracom -| boxtoolsrac.west) {};
    \node (Mc) [left of=mc, node distance=1.3cm] {\circled{M}};
    \draw [mywavyarrow] (Mc) -- (mc);

    \node (sc) [xshift=.2cm, yshift=-.5cm] at (boxracsut -| boxtoolsrac.west) {};
    \node (Sc) [left of=sc, node distance=1.3cm] {\circled{S}};
    \draw [mywavyarrow] (Sc) -- (sc);
\end{tikzannotation}

\caption{\label{figure:tools:rac} Fonctionnement schématique du
\inenglish{Runtime Assertion Checker}.}

\end{figure}

Ce sont les \inenglish{assertion checkers} qui sont responsables d'évaluer
Praspel. Le fonctionnement d'un \inenglish{assertion checker} est illustré dans
la figure~\ref{figure:tools:rac}. Il travaille avec 3~composants~: un modèle
objet qui représente un contrat (provenant par exemple des commentaires des
méthodes), un SUT (par exemple la méthode commentée) et des données. Ces
composants forment un test~! Un \inenglish{assertion checker} est donc capable
de calculer le verdict d'un test.

Actuellement, nous nous appuyons sur un \inenglish{Runtime Assertion Checker},
abrégé RAC, pour calculer le verdict du test. Ce verdict est basé sur la
vérification d'assertions à l'exécution. Quand la vérification d'une assertion
échoue, une erreur spécifique est produite. Les erreurs du RAC (aussi appelées
les \inenglish{Praspel failures} ou erreurs Praspel) peuvent être de 5~sortes~:
%
\begin{enumerate}

\item \inenglish{precondition failure}, quand une précondition n'est pas
satisfaite lors de l'invocation de la méthode~;

\item \inenglish{postcondition failure}, quand une postcondition n'est pas
satisfaite après l'exécution de la méthode~;

\item \inenglish{throwable failure}, quand l'exécution de la méthode lève une
exception inattendue~;

\item \inenglish{invariant failure}, quand un invariant de classe est cassé~; et

\item \inenglish{internal precondition failure}, qui correspond à la propagation
d'une \inenglish{precondition failure} à un niveau supérieur.

\end{enumerate}
%
Le test réussit si aucune erreur Praspel n'est détectée. Autrement, il échoue,
et l'erreur avec des informations supplémentaires est consignée.

À présent, illustrons comment utiliser le RAC de Praspel où le système sous test
est une fonction \code{f} avec un seul paramètre \code{\$i}~:
%
\begin{pre}
\$rac = new Hoa\bslash{}Praspel\bslash{}AssertionChecker\bslash{}Runtime( \\
   \tikzref{codetoolsom} \$model, \\
    xcallable('f')\tikzref{codetoolssut} \\
); \\
\$rac->setData(['i' => 13]); \\
\$verdict = \$rac->evaluate();
\end{pre}
%
\begin{tikzannotation}
    \node (Mc) [left of=codetoolsom, node distance=1.7cm] {\circled{M}};
    \draw [mywavyarrow] (Mc) -- (codetoolsom.center);

    \node (Sc) [right of=codetoolssut, node distance=1.9cm] {\circled{S}};
    \draw [mywavyarrow] (Sc) -- (codetoolssut.east);
\end{tikzannotation}
%
Dans ce cas, la variable \code{\$verdict} contiendra \code{true} car la
précondition (\code{\arequires i: 7..42}) est bien respectée. Si nous voulons
que les données soient générées automatiquement, nous devrons appeler la méthode
\code{\$ac->au\-to\-ma\-ti\-cal\-ly\-Ge\-ne\-ra\-te\-Data(true)} en plus de
définir le générateur numérique par défaut des domaines réalistes afin de
pouvoir appeler les méthodes \code{sample} sur ces derniers~:
%
\begin{pre}
Hoa\bslash{}Realdom::setDefaultSampler(new Hoa\bslash{}Math\bslash{}Sampler\bslash{}Random()); \\
\$rac->automaticallyGenerateData(true); \\
\end{pre}

\begin{example}[Vérifications des assertions]

Dans la figure~\ref{figure:language:short_contract}
page~\pageref{figure:language:short_contract}\footnote{On la replace ici~?}, le
système sous test peut être la méthode \code{store}, le contrat est le contrat
associé à cette méthode et les données sont soit fournies, soit générées
automatiquement. Considérons par exemple la méthode \code{store} et son contrat
dans la figure~\ref{figure:language:short_contract}.
%
Avec le jeu (\code{'foo'}, \code{null}), nous aurons une \inenglish{precondition
failure}~: la contrainte \code{file: class('File')} n'est pas respectée car la
méthode \code{predicate(\$q)} du domaine réaliste \code{Class} avec $\code{\$q}
= \code{'foo'}$ retourne \code{false}, et aucun autre domaine réaliste n'est
spécifié pour cette variable.
%
Avec le jeu de paramètres (\code{new File(…)}, \code{null}), avec un fichier
vide, nous activerons le comportement par défaut et nous n'observerons aucune
erreur sur les préconditions. Nous sommes maintenant dans le post-état. Si la
méthode \code{store} retourne un booléen et que la méthode \code{isAttached} de
l'objet \code{File} retourne \code{true}, aucune erreur non plus sur la
postcondition.  Si cette méthode retourne autre chose que \code{true} ou que la
méthode \code{store} retourne autre chose qu'un booléen, nous aurons une
\inenglish{postcondition failure}. Si une exception est levée, nous aurons une
\inenglish{throwable failure}.
%
Avec le même jeu de paramètres mais un fichier de grande taille ne pouvant être
enregistré, nous activerons le comportement \code{full}. Nous devrons avoir une
exception levée de type \code{AllocationException}, avec une méthode
\code{getFilesystem} qui retournera l'instance de notre système de fichier. Le
fichier ne devra pas non plus être attaché, \ie sa méthode \code{isAttached}
devra retourner \code{false}. Si une autre exception est levée ou que la
postcondition exceptionnelle n'est pas respectée, nous aurons une
\inenglish{throwable failure}. Si aucune exception n'est levée, nous aurons une
\inenglish{postcondition failure}.
%
Si avant ou après l'exécution de la méthode \code{store}, un invariant est
cassé, nous aurons une \inenglish{invariant failure}. Par exemple, si l'attribut
\code{\_map} contient autre chose que des objets \code{File} ou que sa taille
dépasse 65535.
%
Enfin, si la méthode \code{store} fait appel à la méthode \code{getUsage} en ne
respectant pas sa précondition (ici en lui donnant un argument par exemple),
alors une \inenglish{precondition failure} sera émise depuis la méthode
\code{getUsage}, qui sera ensuite traduite en \inenglish{internal precondition
failure} depuis la méthode \code{store}.

\end{example}

\subsection{Hoa, un ensemble de bibliothèques PHP}
\label{subsection:tools:hoa}

Hoa~\acite{Hoa} est un ensemble de bibliothèques PHP. De plus, Hoa est un pont
entre le monde de la recherche et de l'industrie. Ce projet comporte des
bibliothèques solides pour une multitude de domaines. Entre autre, il offre une
consistence entre les versions de PHP et est très respectueux des standards. Hoa
est également impliqué dans plusieurs consortiums ou groupes de décisions
concernant plusieurs standards de l'Informatique ou du Web. Par conséquent, il
est plus facile d'écrire, de maintenir et de s'assurer de la qualité des
programmes constituants Praspel.

De plus, le fait que Hoa souhaite être un pont entre le monde de la recherche et
de l'industrie nous offre l'opportunité de faire valider nos expérimentations
par sa communauté ou ses utilisateurs. Mais aussi, Hoa est développé sous la
licence libre \inenglish{New BSD License}\footnote{Voir
\url{http://hoa-project.net/En/About.html\#License}.}, soit une licence
\inenglish{open-source}. Cela implique que les outils que nous avons développé
durant cette thèse, comme Praspel, le compilateur etc., sont gratuits et libres.
Cette approche offre deux avantages majeurs. Tout d'abord, des contributeurs de
tout horizon peuvent nous aider à corriger ou améliorer nos outils. Ça a été le
cas à plusieurs reprises où des contributeurs ont corrigé des erreurs dans
Praspel ou ont amélioré considérablement le compilateur, notamment en y ajoutant
le support Unicode, en améliorant les performances de l'analyseur lexical (pour
l'analyse de très grandes données) etc. Ensuite, puisque les outils sont
gratuits, l'industrie peut l'utiliser et nous offrir des retours pertinents,
comme nous le verrons dans le chapitre~\ref{chapter:experimentations} avec les
expérimentations.

Nos contributions et outils prennent la forme de bibliothèques dans Hoa, à
savoir \code{Hoa\bslash{}Realdom} pour les domaines réalistes,
\code{Hoa\bslash{}Praspel} pour le langage Praspel, \code{Hoa\bslash{}Compiler}
pour le compilateur et \code{Hoa\bslash{}Regex} pour les expressions régulières.
D'autres contributions plus minimes ne sont pas détaillées ici, comme l'ajout de
fonctionnalités dans la bibliothèque \code{Hoa\bslash{}Math}.

\subsubsection{\code{Hoa\bslash{}Realdom}}

La bibliothèque \code{Hoa\bslash{}Realdom}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Realdom}.} représente la
bibliothèque standard des domaines réalistes. Ils sont implémentés comme
présenté dans la partie~\ref{section:language:realdoms}
page~\pageref{section:language:realdoms}, à savoir que chaque domaine réaliste
est représenté par une classe.  Actuellement, une liste de 28~domaines réalistes
est proposée~:
%
\begin{itemize}

\item \code{Array}, représentant des tableaux~;

\item \code{Bag}, un sac pouvant contenir plusieurs domaines réalistes de
natures différentes~;

\item \code{Boolean}, représentant les booléens~;

\item \code{Boundfloat}, représentant un intervalle de réels~;

\item \code{Boundinteger}, représentant un intervalle d'entiers~;

\item \code{Class}, représentant des instances de classes~;

\item \code{Color}, représentant des couleurs au format \code{\#{\em rrggbb}}~;

\item \code{Constarray}, représentant les tableaux de Praspel, c'est~à~dire une
description de tableau~;

\item \code{Constboolean}, représentant les booléens de Praspel~;

\item \code{Constfloat}, représentant les réels de Praspel~;

\item \code{Constinteger}, représentant les entiers de Praspel~;

\item \code{Constnull}, représentant la valeur nulle de Praspel~;

\item \code{Conststring}, représentant les chaînes de caractères de Praspel~;

\item \code{Date}, représentant une date formatée~;

\item \code{Empty}, représentant une donnée vide~;

\item \code{Even}, représentant les nombres pairs~;

\item \code{Float}, représentant les réels~;

\item \code{Grammar}, représentant les chaînes de caractères spécifiées par une
grammaire~;

\item \code{Integer}, représentant les entiers~;

\item \code{Natural}, représentant les naturels (entiers auto-incrémentés)~;

\item \code{Number}, représentant les nombres (entiers ou réels)~;

\item \code{Object}, représentant un objet donné~;

\item \code{Odd}, représentant les nombres impairs~;

\item \code{Regex}, représentant les chaînes de caractères spécifiées par une
expression régulière~;

\item \code{Smallfloat}, représentant des petits réels~;

\item \code{Smallinteger}, représentant des petits entiers~;

\item \code{String}, représentant des chaînes de caractères~;

\item \code{Timestamp}, représentant des valeurs dans le temps~;

\item \code{Undefined}, représentant des valeurs non-définies.

\end{itemize}

Pour obtenir toutes les informations sur un domaine réaliste, nous pouvons nous
aider de l'outil en ligne de commande \code{hoa realdom:reflection}.

\begin{example}[Informations sur le domaine réaliste \code{Boundinteger}]

Par exemple, pour obtenir des informations sur le domaine réaliste
\code{Boundinteger}, en ligne de commande, nous ferons~:
%
\begin{bigpre}
\$ hoa realdom:reflection boundinteger \\
Realdom boundinteger \{ \\
 \\
    Implementation Hoa\bslash{}Realdom\bslash{}Boundinteger; \\
 \\
    Parent Hoa\bslash{}Realdom\bslash{}Integer; \\
 \\
    Interfaces \{ \\
 \\
        ArrayAccess; \\
        Countable; \\
        IteratorAggregate; \\
        Traversable; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Enumerable; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Finite; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Interval; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Nonconvex; \\
        Hoa\bslash{}Realdom\bslash{}Number; \\
        Hoa\bslash{}Visitor\bslash{}Element; \\
    \} \\
 \\
    Parameters \{ \\
 \\
        [#0 optional] Constinteger lower = -9223372036854775808; \\
        [#1 optional] Constinteger upper = 9223372036854775807; \\
    \} \\
\}
\end{bigpre}
%
Nous trouvons comme informations le nom de la classe qui représente
l'implémentation du domaine réaliste, toutes les interfaces utilisées par cette
implémentation (ici plusieurs de PHP et des domaines réalistes, comme présenté
dans la partie~\ref{subsection:language:realdom:classification}
page~\pageref{subsection:language:realdom:classification}), ainsi que les
paramètres avec leurs positions, filtres et valeurs par défaut.

\end{example}

Cette bibliothèque peut être utilisée seule, sans Praspel.

\subsubsection{\code{Hoa\bslash{}Praspel}}

La bibliothèque \code{Hoa\bslash{}Praspel}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Praspel}.} est responsable
de tout le support de Praspel, de l'interprétation à l'évaluation en passant par
la compilation, la couverture des contrats etc. La bibliothèque est découpée de
la façon suivante~:
%
\begin{itemize}

\item \code{AssertionChecker}, permet l'évaluation du modèle objet~;

\item \code{Bin}, contient des scripts, dont un \inenglish{shell} permettant
d'analyser et évaluer du code Praspel à la volée~;

\item \code{Exception}, contient toutes les catégories d'exceptions de Praspel,
dont les \inenglish{Praspel failures}~;

\item \code{Iterator}, contient entre autre les générateurs de tests unitaires à
partir de plusieurs critères de couverture sur un contrat~;

\item \code{Model}, contient le modèle objet, à savoir la pièce central du
langage Praspel~;

\item \code{Preambler}, permet de créer un préambule de test pour n'importe quel
système sous test~;

\item \code{Visitor}, contient l'interpréteur, le compilateur et le
désassembleur.

\end{itemize}

À la racine de la bibliothèque, nous trouvons entre autre la grammaire au format
PP, une classe nommée \code{Hoa\bslash{}Praspel} qui rassemble les opérations
usuelles sur le langage et une classe représantant une trace d'évaluation d'un
contrat. Le lien entre Praspel et les domaines réalistes se fait au niveau du
modèle objet dans la classe
\code{Hoa\bslash{}Praspel\bslash{}Model\bslash{}Variable}.

\subsubsection{\code{Hoa\bslash{}Compiler} et \code{Hoa\bslash{}Regex}}

Le compilateur LL($\star$) que nous avons développé dans la
partie~\ref{section:data:strings} page~\pageref{section:data:strings} est
représenté par la bibliothèque
\code{Hoa\bslash{}Compiler\bslash{}Llk}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Compiler}.} (un autre
compilateur LL(1) existait préalablement). Cette bibliothèque comprend aussi le
support du langage PP ainsi que des algorithmes de générations à partir de
grammaires, soient~: aléatoire uniforme, exhaustif borné et par couverture. Ces
algorithmes sont présents dans la sous-bibliothèque
\code{Hoa\bslash{}Com\-pi\-ler\bslash{}Llk\bslash{}Sam\-pler}.  Seuls les deux
derniers fonctionnent comme des itérateurs.

\begin{example}[Génération exhaustive bornée avec Hoa]

Pour générer toutes les données au format JSON dont la taille maximum des
séquences de lexèmes ne dépasse pas 10, nous écrirons~:
%
\begin{pre}
\$sampler = new Hoa\bslash{}Compiler\bslash{}Llk\bslash{}Sampler\bslash{}BoundedExhaustive( \\
    Hoa\bslash{}Compiler\bslash{}Llk::load( \\
        new Hoa\bslash{}File\bslash{}Read('hoa://Library/Json/Grammar.pp') \\
    ), \\
    new Hoa\bslash{}Regex\bslash{}Visitor\bslash{}Isotropic( \\
        new Hoa\bslash{}Math\bslash{}Sampler\bslash{}Random() \\
    ), \\
    10 \\
); \\
 \\
foreach(\$sampler as \$data) \\
    // compute \$data
\end{pre}

L'ordre des arguments des générateurs est toujours le même. En premier, nous
devons fournir la grammaire, puis le générateur pour les lexèmes et enfin, si
besoin, la taille (fixe, minimum ou maximum selon le générateur) de la donnée à
générer. Le seul générateur de lexème proposé actuellement est isotropique,
comme présenté dans la partie~\ref{subsection:data:isotropic_generation}
page~\pageref{subsection:data:isotropic_generation}.

\end{example}

La grammaire des expressions régulières se trouve également dans la bibliothèque
\code{Hoa\bslash{}Regex}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Regex}.} dans
\code{hoa://Library/Regex/Grammar.pp}.
