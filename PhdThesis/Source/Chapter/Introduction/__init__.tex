\chapter{Introduction}
\label{chapter:introduction}

\minitoc

Les travaux présentés dans ce mémoire sont liés à des activités relatives à la
validation et à la vérification de programmes PHP à travers un nouveau langage
de spécification accompagné de ses outils. Ces activités s'articulent autour de
trois axes majeurs~: langage de spécification, génération automatique de données
de tests et génération automatique de tests unitaires. \\

Aujourd'hui, nous sommes dans l'ère du tout numérique. Le nombre de nouveaux
logiciels produits et utilisés chaque jour est énorme. Nous utilisons de plus en
plus de machines dans notre quotidien~: téléphones, tablettes, ordinateurs,
télévisions, appareils électroménagers… Une très grande majorité d'entre eux
sont connectés à un réseau, le plus souvent Internet. Ce dernier nous permet
d'accéder à des millers de millions de sites Web. Plus de 85\% de ces sites Web
sont développés en PHP. Tous ces programmes ont besoin d'être vérifiés et
validés.

Ce mémoire s'intéresse au test logiciel. Informellement, nous pouvons voir un
test comme étant composé de trois parties~:
%
\begin{enumerate}

\item un Système Sous Test (\inenglish{System Under Test}, abrégé {\strong
SUT})~;

\item des {\strong données de test} pour exécuter ce SUT~;

\item un {\strong oracle}, capable de nous calculer le verdict du test~: est-ce
que le produit de l'exécution et l'état du SUT après son exécution sont ceux
attendus ou non~?

\end{enumerate}

Aujourd'hui, dans le monde industriel, la majorité des tests sont écrits
{\strong manuellement}, par des ingénieurs de test. Un SUT leur est fourni, ils
l'exécutent avec des données de test et calculent eux-même le verdict du test.
Dans le cas des tests {\strong automatisés}, l'exécution et le calcul du verdict
sont faits par la machine. C'est le rôle qui incombe aux \inenglish{frameworks}
«~xUnit~», comme JUnit~\acite{JUnit} pour Java, atoum~\acite{atoum} ou
PHPUnit~\acite{PHPUnit} pour PHP, CUnit~\acite{CUnit} pour C etc. Le travail des
ingénieurs de test peut se résumer à écrire une spécification informelle
exécutable, puisqu'ils transforment le cahier des charges en tests afin de
vérifier et valider le programme. Cela reste toutefois informel, et surtout, une
tâche laborieuse qui peut revenir cher. Pourquoi alors ne pas écrire une
spécification formelle et la rendre exécutable~? C'est~à~dire utiliser un
langage formel pour décrire le fonctionnement du programme, puis dériver, à
partir de cette spécification, des tests qui soient exécutables et qui vont
vérifier ou valider plusieurs aspects de cette spécification.

\section{\inenglish{Behavioral Interface Specification Language}}

Le terme {\strong spécification} signifie généralement une description précise
d'un comportement d'un artéfact. {\strong Vérification} signifie prouver qu'une
implémentation (c'est~à~dire un programme) satisfait une spécification
particulière dans toutes les exécutions et configurations possibles.
Généralement, une telle preuve est accomplie à l'aide de raisonnements
statiques, c'est~à~dire uniquement par analyse du programme. Lorsqu'un
raisonnement statique n'est pas possible ou suffisant, nous pourrons utiliser
une {\strong validation} dynamique, pour tester l'implémentation, c'est~à~dire
que nous exécuterons le programme. Une validation dynamique est aussi appelée
\inenglish{Runtime Assertion Checking}, abrégé RAC~\acite{Geller76}.

Un {\strong langage de spécification} formel est une notation précise pour
décrire les comportements et propriétés d'un programme. Les {\strong notations
formelles} aident à rendre les spécifications non-ambiguës, moins dépendantes
des normes culturelles, et ainsi moins sujettes à une mauvaise interprétation.
Les langages de spécification sont conçus pour répondre à des problèmes généraux
ou spécialisés. Les langages de spécifications généraux, tels que
Z~\acite{Spivey89} ou OCL~\acite{RichtersG98}, ne sont pas conçus pour une
méthodologie particulière ou des outils de vérifications. Cependant, les
langages de spécifications sont très souvent spécialisés, en fonction de la
catégorie de langage qu'ils visent~: typage statique et fort, ou dynamique et
faible, orienté objet ou fonctionnel etc.

Par ailleurs, comme une notation est formelle, elle peut être exploitée par une
machine pour y appliquer un traitement automatique. Les spécifications
formelles peuvent alors aider à {\strong automatiser le test}, autant pour
générer les données de test~\acite{BernotGM91, KorelA98, SankarH94, Jalote92}
que pour calculer le verdict du test~\acite{CheonL02}. C'est dans ces deux
directions que nous allons nous tourner.

Les spécifications peuvent documenter les {\strong interfaces} d'un programme.
Par interfaces, il faut comprendre les parties du programme permettant de
manipuler les données. Nous parlons alors de {\strong langages d'annotations}.
De tels langages peuvent jouer un rôle central dans la programmation. Par
exemple, ils facilitent la maintenance du code, qui n'est généralement pas
suffisament expressif pour faire comprendre au développeur ses tenants et ses
aboutissants. Par ailleurs, lors d'une phase de \inenglish{debugging}, les
annotations permettent de localiser plus facilement la faute. Dans le cas où
nous travaillons en boîte blanche (\inenglish{white-box}), c'est~à~dire où nous
avons accès au code source du programme, les annotations peuvent faire partie de
la grammaire du langage, ou alors, elles sont écrites dans des {\strong
commentaires}. Dans le cas où nous travaillons en boîte noire
(\inenglish{black-box}), c'est~à~dire où nous n'avons pas ou partiellement accès
au code source, les annotations peuvent parfois être externes au programme, par
exemple sur un langage de définition d'interface (\inenglish{Interface
Definition Language}, abrégé IDL) ou sur un modèle, ce qui nous rapprocherait du
\inenglish{Model-based Testing}, abrégé MbT~\acite{Utting07}. La différence
entre boîte noire et boîte blanche peut parfois être plus
subtile~\acite{Gaudel11}~: nous considérons que nous sommes en boîte noire quand
nous n'exploitons pas la structure du code, basiquement le contenu des fonctions
et méthodes, sinon, nous sommes en boîte blanche.

Les langages d'annotations sont des \inenglish{Behavioral Interface
Specification Language}, abrégé BISL. C'est dans cette catégorie de langage que
se situent nos contributions.

\section{Contexte et problématique}

Ce mémoire s'intéresse à la conformité entre un programme et sa spécification, à
travers la création d'un nouveau langage de spécification simple, pragmatique
pour le Web et les développeurs et assemblant plusieurs méthodes du test. Chaque
méthode introduite se verra enrichie pour la rendre compatible avec les besoins
liés au Web. Les parties suivantes expliquent notre motivation, notre contexte
et nos enjeux.

\subsection{\inenglish{PHP: Hypertext Preprocessor}}

PHP~\acite{PHP} se définit comme étant un «~langage de script universel
populaire qui est particulièrement adapté pour le développement Web~». PHP se
définit également avec les adjectifs suivants~: «~rapide, flexible et
pragmatique~». C'est aussi un langage multiparadigmes. Il est par exemple
procédural avec des fonctions nommées, orienté objet avec des classes (héritage
vertical), des interfaces (typage) et des traits (héritage horizontal), ou
encore fonctionnel avec des fonctions anonymes ($\lambda$) et des closures
($\overline{\lambda}$). Son système de typage est dynamique et faible,
c'est~à~dire que les types sont non-déclarés et qu'il est possible de transtyper
les données. PHP est un langage de script interprété. Il existe plusieurs
interpréteurs, appelés des machines virtuelles. Nous pouvons voir PHP comme un
langage «~glu~» (comme la majorité des langages de script), c'est~à~dire qu'il
communique avec à peu prêt tout et est au centre de beaucoup de logiciels. La
syntaxe du langage est inspirée de C, C++, Java ou encore Perl.  Depuis
plusieurs années, le langage connaît des améliorations importantes afin de faire
oublier les erreurs de modélisation passées qui lui sont trop souvent associées.
Nous nous intéressons à des programmes écrits en PHP pour plusieurs raisons
décrites dans cette partie et les suivantes.

Comparés à des langages plus traditionnels, comme C ou Java, les langages de
scripts accélèrent le processus de développement grâce à la flexibilité qu'ils
offrent avec un typage dynamique, faible et un mélange de paradigmes. Cependant,
cette flexibilité rend plus difficile la compréhension du comportement de
certains programmes, tout comme il est plus difficile de s'assurer que le
programme n'est pas affecté par une modification (nous parlons de régressions).

Par ailleurs, plus de 85\% du Web fonctionne avec PHP. Cela implique qu'il y a
un marché important avec d'immenses besoins~; que ce soient des sites de
commerces\footnote{Etsy, \url{https://etsy.com/}.}, de banques, d'assurances, de
réseaux sociaux\footnote{Facebook, \url{https://facebook.com/}.}, de moteurs de
recherche\footnote{Yahoo, \url{https://yahoo.com/}.},
d'encyclopédies\footnote{Wikipedia, \url{https://wikipedia.org/}.},
gouvernementaux\footnote{France, Belgique, Suisse, USA, Canada etc.} et autres.
Tous ces domaines ont besoin de qualité logicielle.

\subsection{Test unitaire}

Plusieurs travaux cherchent à améliorer la sécurité des programmes écrits en PHP
à l'aide d'analyses statiques~\acite{YuAB10, BalzarottiCFJKKV08, WassermannS08,
WassermannS07, Xie06} du code source, des flots des données pour trouver des
chaînes de caractères malicieuses, des injections SQL etc. Toutefois, un grand
nombre des solutions proposées souffrent de limitations
majeures~\acite{HauzarK12} comme une détection faible des erreurs, un taux de
faux-positifs important ou même un support faible des constructions du langage~;
l'aspect dynamique et multiparadigmes du langage n'aidant pas. D'autres travaux
testent PHP à un niveau plus élevé, par exemple en testant le site Web écrit en
HTML directement~\acite{ArtziKDTDPE10, KiezunGJE09, McAllisterKK08, Benedikt02}.
Ces travaux se situent du côté client et observent les résultats produits par
PHP côté serveur. Ces travaux sont intéressants pour, d'une part, tester la
sécurité, et d'autre part, tester des programmes existants.

Toutefois les méthodes de développement ont énormément évolué ces dernières
années avec la qualité logicielle~\acite{LepineSF09}. Les horribles programmes
tels ceux que nous avons lus ou écrits en PHP ont disparu. Des nouveaux
\inenglish{frameworks} ou de nouvelles bibliothèques PHP ont fait leur
apparition et mettent en avant l'usage intensif de bonnes pratiques pour le
développement de programmes maintenables et testables. Des
\inenglish{frameworks} de tests de plusieurs natures ont également fait leur
apparition et un programme non-testé ne sera même plus installé. 

De plus, aucun travail de recherche n'a fait de propositions pour spécifier des
programmes écrits en PHP et pourtant cela permettrait d'éviter en amont une
multitude de problèmes. Enfin, aucun travail ne considère PHP pour la génération
automatique de données de test ou encore la génération automatique de tests
unitaires.

Nous profitons de cette tendance d'amélioration de la qualité logicielle et de
l'absence de travaux dans le domaine des langages de spécification pour
introduire les contrats dans PHP. Nos travaux s'inscrivent au niveau des tests
unitaires et au niveau du programme PHP lui-même, c'est~à~dire que nous ne
tenons pas compte du contexte d'utilisation du programme (client-serveur, client
seul, démon etc.).

\subsection{Langage de contrat}

Comme PHP est un langage «~glu~», il manipule des données de toutes sortes.
C'est une première contrainte. De plus, les utilisateurs de PHP sont aussi bien
des débutants que des experts. La palette des utilisateurs est très large. C'est
un avantage et un inconvénient du langage~: il est simple à utiliser et permet
d'obtenir des résultats rapidement mais il permet aussi de faire des choses très
poussées. Toutefois, tous ces utilisateurs suivent la tendance d'amélioration de
la qualité logicielle. C'est une deuxième contrainte. Enfin, le langage PHP est
très pragmatique, c'est ce qui le rend si facile d'accès. Les choses ne sont pas
toujours faites comme elles le devraient, mais elles sont tout de même bien
faites. La majorité des fonctionnalités du langage sont des compromis. Les
utilisateurs du langage sont habitués à ce pragmatisme. C'est une troisième
contrainte.

Si nous proposons un langage de spécification pour PHP, il doit impérativement
tenir compte de ces trois contraintes. Il doit être simple pour être utilisé et
compris par la majorité des utilisateurs. Il doit être pragmatique pour que le
travail puisse être fait rapidement et comme il faut. L'objectif n'est pas
d'adresser tous les problèmes mais les problèmes les plus courants et les plus
préoccupants. Nous ne ferons pas de compromis, nous sommes des scientifiques,
mais nous pouvons trouver une manière élégante de présenter des solutions. Et
enfin, puisque culturellement PHP est un langage «~glu~» et que nous voulons
adresser plusieurs problèmes, le langage de spécification que nous proposons
doit assembler plusieurs méthodes du test. Ces trois points, notamment le
dernier, sont de réels \inenglish{challenges} scientifiques.

Nous pensons que la programmation par contrat est pertinente pour répondre à
toutes ces contraintes.

\section{Contributions}
\label{section:introduction:contributions}

Dans ce mémoire, nous proposons un nouveau langage de contrat pour PHP. À partir
de ce langage, nous voulons être capables de générer automatique des tests
unitaires. Ainsi, nous avons trois axes de réflexion~: le langage lui-même (sa
syntaxe et sa sémantique), les algorithmes de génération de données, et enfin
les algorithmes de génération de tests unitaires. Nous voulons que les
générations soient automatiques, c'est~à~dire que l'humain intervienne le moins
possible.

\subsection{Praspel, un langage de contrats pour PHP, et des domaines réalistes}

Le langage de contrat que nous proposons s'appelle {\strong Praspel}. Un contrat
peut être utilisé de deux façons différentes~: soit il sera évalué lors de
l'exécution du programme afin de vérifier qu'aucune spécification ne soit
violée, soit nous pouvons à partir d'un contrat générer automatiquement
plusieurs tests unitaires. Cette seconde option est traitée dans les
contributions suivantes. Cette contribution s'intéresse au langage en lui-même,
à savoir sa syntaxe et sa sémantique. Nous voyons aussi comment évaluer un
contrat pour qu'il vérifie des données à l'exécution. Ce langage est inspiré de
JML~\acite{JML} mais se différencie sur la façon de spécifier les données. En
effet, il s'appuye en grande partie sur les {\strong domaines réalistes}, des
structures permettant de valider et générer des données et pouvant être
emboîtées afin de représenter des données plus complexes. Cette contribution a
été publiée dans~\acitei{EnderlinDGO11}.

\subsection{Générateurs de données}

Nous avons dit qu'un contrat pouvait être utilisé pour générer automatiquement
des tests unitaires. Un test est constitué de trois choses~: un SUT, des données
de test et un oracle. Cette contribution s'intéresse à générer des données de
test. Ces données sont spécifiées au mieux par le contrat. Nous devons alors
être capables de générer toutes sortes de données~: des booléens, des entiers,
des réels, des chaînes de caractères, des tableaux, des objets etc. Nous avons
commencé par générer aléatoirement et uniformément des booléens, des entiers et
des réels. Toutefois, cette approche montre rapidement ses limites avec des
chaînes de caractères, des tableaux ou des objets. Nous avons proposé des
algorithmes de génération de chaîne de caractères s'appuyant sur des
grammaires. Ensuite, nous nous sommes concentrés sur les tableaux avec un
solveur et des contraintes dédiées. Ces contributions ont donné lieux à deux
publications, respectivement \acitei{EnderlinDGB12} et \acitei{EnderlinGB13}.
Enfin, nous avons pu améliorer la génération des objets en combinant toutes ces
approches.

\subsection{Critères de couverture des contrats}

Cette dernière contribution «~boucle la boucle~». Nous avons un langage de
contrat qui peut être évalué pour vérifier les données manipulées par le
programme à l'exécution. Nous sommes capables de générer automatiquement des
données de test à partir d'un morceau d'un contrat. La dernière étape
s'intéresse au fait qu'un contrat peut exprimer plusieurs comportements et nous
devons nous assurer que tous ces comportements sont testés. Nous avons alors
défini plusieurs critères de couverture sur les contrats afin d'avoir des
objectifs de tests à atteindre. Par conséquent, nous avons développé des
algorithmes générant autant de tests unitaires que nécessaire pour satisfaire
certains critères et ainsi couvrir tous les comportements des contrats. Les
données nécessaires pour exécuter ces tests seront générées automatiquement avec
la contribution précédente.

\section{Plan du mémoire}

Ce mémoire s'articule en 8~chapitres plus annexes et bibliographie~:
%
\begin{enumerate}[$\mathrm{chapitre}$ 1,]

\item ce chapitre, avec l'introduction, le contexte, la problématique et les
contributions~;

\item contient l'état de l'art nécessaire pour comprendre cette thèse et situer
nos contributions~;

\item présente les domaines réalistes ainsi que Praspel, au niveau syntaxique et
sémantique~;

\item présente les différents algorithmes et stratégies de génération de données
de test~;

\item présente les critères de couverture pour obtenir des objectifs de test à
satisfaire afin de produire des tests unitaires pertinents~;

\item décrit les outils développés durant ce mémoire ou les outils incluant nos
travaux~;

\item valide nos contributions à travers des expérimentations~;

\item présente les conclusions et les perspectives.

\end{enumerate}
%
Les chapitres 3 à 6 sont des contributions. Le chapitre 7 valide ces
contributions par des expérimentations. Une des expérimentations a une approche
originale mettant en avant des résultats qualitatifs.
