\section{Domaines réalistes}
\label{section:language:realdoms}

Un des moyens les plus répandus pour caractériser une donnée est d'utiliser des
types. Malheureusement, la majorité des langages interprétés, dont PHP, n'a pas
de type. Plus précisément, PHP a un système de typage dynamique. Cela signifie
que les types ne sont pas déclarés syntaxiquement mais déduits lors de
l'exécution. De plus, PHP a un système de typage faible. Cela signifie qu'il est
très facile de transtyper une donnée, c'est à dire de passer d'un type vers un
autre. Par exemple, l'addition de la chaîne de caractères \code{'1.2'} avec
l'entier \code{4} produit le réel \code{5.2}.

Pour compenser l'absence d'informations à propos des données, nous proposons les
domaines réalistes. Naïvement, nous pouvons dire qu'ils raffinent les types
usuels comme les entiers, les chaînes de caractères, les tableaux etc., ainsi
que des types plus complexes. Le mot {\em réaliste} signifie qu'ils sont conçus
pour spécifier des domaines de données pertinentes pour un contexte spécifique.
Par exemple, une adresse email peut être un domaine réaliste~: plusieurs
logiciels identifient leurs utilisateurs avec leur adresse email. C'est plus
qu'une chaîne de caractères, ça doit respecter certaines règles, notamment
syntaxiques.

Les domaines réalistes ont été conçus afin de répondre aux problématiques de
test. C'est pourquoi ils ont les deux propriétés suivantes~:

\begin{itemize}

\item la {\em prédicabilité} permet de vérifier qu'une donnée appartient à
l'ensemble des valeurs décrites par le domaine réaliste~;

\item la {\em générabilité} permet de générer une valeur décrite par le domaine
réaliste.

\end{itemize}

Ces deux propriétés permettent respectivement de {\em valider} et de {\em
vérifier} un programme.

\subsection{Implémentation}
\label{subsection:language:realdom:implementation}

Nous proposons une implémentation des domaines réalistes en PHP. Dans cette
implémentation, un domaine réaliste est représenté par une classe, et ses
propriétés de prédicabilité et de générabilité par les méthodes respectives
suivantes~:

\begin{itemize}

\item \code{predicate(\$q)}, où \code{\$q} est la valeur à valider~;

\item \code{sample(\$sampler)}, où \code{\$sampler} est un {\em générateur
numérique}~: il génère uniquement des entiers et des réels, et permet de guider
la génération d'une donnée~; par exemple nous allons utiliser ce générateur
numérique pour choisir un caractère parmi une plage de caractères donnés.  Pour
l'instant, le seul générateur numérique disponible est pseudo-aléatoire.

\end{itemize}

\subsection{Hiérarchie}
\label{subsection:language:realdom:hierarchy}

Parce que les domaines réalistes sont implémentés à travers des classes et que
PHP est orienté objet, nous pouvons faire de l'héritage. Par conséquent, un
domaine réaliste enfant peut hériter et rafiner les propriétés de son parent.
Par exemple, le domaine réaliste \code{Color} hérite de \code{String}, et
\code{Boundinteger} hérite de \code{Integer}. Tous les domaines réalistes
doivent être enfant de la classe \code{Realdom}.

La Figure~\ref{figure:language:realdom_boundinteger} montre une implémentation
légère du domaine réaliste \code{Boundinteger}. Il hérite du domaine réaliste
\code{Integer} en \circled{1}. La propriété de prédicabilité rafine celle du
parent en \circled{2}, and ajoute de nouvelles contraintes en \circled{3} et en
\circled{4}.

\begin{figure}[t]
\begin{pre}
class Boundinteger extends Integer /* \(\circled{1} \)*/ \{ \\
\\
    protected \$_arguments = array( \\
        'Constinteger lower' => PHP_INT_MIN, /* \(\circled{5}\) */ \\
        'Constinteger upper' => PHP_INT_MAX  /* \(\circled{6}\) */ \\
    ); \\
\\
    public function predicate ( \$q ) \{ \\
\\
        return    parent::predicate(\$q)                     /* \(\circled{2}\) */ \\
               && \$q >= \$this['lower']->getConstantValue()  /* \(\circled{3}\) */ \\
               && \$q <= \$this['upper']->getConstantValue(); /* \(\circled{4}\) */ \\
    \} \\
\\
    public function sample ( \$sampler ) \{ \\
\\
        return \$sampler->getInteger( \\
            \$this['lower']->sample(\$sampler), \\
            \$this['upper']->sample(\$sampler) \\
        ); \\
    \} \\
\}
\end{pre}

\caption{\label{figure:language:realdom_boundinteger} Implémentation légère du
domainer réaliste \code{Boundinteger}. Nous pouvons voir l'héritage, les
propriétés de prédicabilité et de générabilité à travers les méthodes
\code{predicate} et \code{sample}, le rafiner et la déclaration des paramètres.}

\end{figure}

\subsection{Paramèters}
\label{subsection:language:realdom:parameters}

{\em A l'instar} des fonctions, les domaines réalistes sont paramétrables. Les
données reçues par le domaine réaliste sont appelées ses {\em arguments}. Les
paramètres sont très utiles pour représenter des structures de données
complexes, telles que des tableaux imbriqués, des graphes, des automates, des
arbres etc.

Par exemple, le domaine réaliste \code{string(0x61, 0x7a, boundinteger(4, 12))}
représente une chaîne de caractères dont la taille est comprise entre 4 et 12 et
dont les code-points des caractères entre \code{0x61} et \code{0x7a}. Nous
pouvons écrire \code{4..12}, qui est un sucre syntaxique.

Quand nous décrivons les paramètres d'un domaine réaliste, nous pouvons indiquer
leur type. Le type est exprimé à travers le ou les noms d'un des domaines
réalistes. En effet, un domaine réaliste accepte plusieurs sortes d'arguments et
est capable de faire la traduction d'un type vers un autre lui-même. Ainsi, nous
restons proche de la philosophie de PHP. Par exemple, pour le domaine réaliste
\code{String}, ses deux premiers paramètres peuvent être des entiers ou des
caractères. Alors, nous pouvons écrire \code{string('a', 'z', 4..12)} sans
produire d'erreur, mais \code{string(true, 'z', 4..12)} produira une erreur.

La Figure~\ref{figure:language:realdom_boundinteger} montre la déclaration de
deux paramètres~: \code{lower} en \circled{5} et \code{upper} en \circled{6}.

\subsection{Classification}
\label{subsection:language:realdom:classification}

L'héritage est une classification. Une autre classification transversale est
possible grâce aux interfaces. Elles aident à caractériser le «~paysage~» des
domaines réalistes. Les interfaces les plus intéressantes sont~:

\begin{itemize}

\item \code{Constant}, pour représenter un domaine réaliste immuable avec
seulement une valeur, comme \code{42} (du domaine réaliste \code{Constinteger}),
\code{true} (du domaine réaliste \code{Constboolean}), etc.~;

\item \code{Interval}, pour représenter un intervalle à travers une borne
inférieure et supérieure, qui peuvent être réduites dynamiquement (à
l'exécution)~;

\item \code{Finite}, pour représenter un domaine réaliste avec un ensemble de
valeurs dénombrable~;

\item \code{Nonconvex}, pour représenter un domaine réaliste avec des trous, \ie
où des valeurs ont été exclues, et donc, ne peuvent plus être générées~;

\item \code{Enumerable}, pour représenter un domaine réaliste dont les valeurs
peuvent être énumérées, comme \code{Integer}.

\end{itemize}

Ainsi, par exemple, un domaine réaliste qui implémente les interfaces
\code{Interval} et \code{Nonconvex} représente un intervalle à trous.
