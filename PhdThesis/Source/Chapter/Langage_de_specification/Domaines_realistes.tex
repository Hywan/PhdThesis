\section{Domaines réalistes}
\label{section:language:realdoms}

Un des moyens les plus répandus pour caractériser les données manipulées par un
programme est d'utiliser un système de {\strong typage}. Il en existe
grossièrement deux grandes familles~: {\strong statique} et {\strong dynamique},
que nous pouvons comprendre comme types déclarés syntaxiquement ou déduits lors
de la compilation ou de l'exécution. Dans tous les cas, le type d'une donnée est
connu au moment de l'{\strong exécution} du programme. Le typage permet de
{\strong vérifier} la cohérence entre les données manipulées. Ainsi, la plupart
des systèmes de typage ne permettent pas l'addition d'une chaîne de caractères
avec un entier, sauf si ce système est dit {\strong faible}. Prenons l'exemple
de PHP qui a un système de typage dynamique (déduit à l'exécution) et faible~:
l'addition de la chaîne de caractères \code{'1.2'} avec l'entier \code{4}
produit le réel \code{5.2}. Dans ce cas, le langage opère un transtypage,
c'est~à~dire qu'à partir de règles internes il transforme les données vers un
autre type.

Notons que dans un langage comme PHP où les types ne sont pas déclarés
syntaxiquement, il est culturellement admis d'écrire une documentation API qui
décrit la nature des données manipulées par le programme, comme ses types.

Nous profitons du fait que les développeurs connaissent bien les systèmes de
typage grâce à leur présence quasi permente dans tous les langages pour
introduire la notion de {\strong domaine réaliste}. Naïvement, nous pouvons dire
qu'ils raffinent les types usuels comme les entiers, les chaînes de caractères,
les tableaux etc., et qu'ils permettent d'exprimer des types plus complexes,
comme des grammaires, des graphes etc. Le mot {\strong réaliste} signifie qu'ils
sont conçus pour spécifier des domaines de données {\strong pertinentes} pour un
contexte {\strong spécifique}. Par exemple, une adresse email peut être un
domaine réaliste. En effet, plusieurs logiciels identifient leurs utilisateurs
avec leur adresse email. C'est plus qu'une chaîne de caractères~: il y a une
certaines règles, notamment syntaxiques, à respecter.

\begin{definition}[Caractéristiques d'un domaine réalistes]
\label{definition:language:realdom}

Les domaines réalistes ont été conçus afin de répondre aux problématiques de
test. C'est pourquoi ils ont les deux caractéristiques suivantes~:

\begin{itemize}

\item la {\strong prédicabilité} qui permet de vérifier qu'une donnée appartient
à l'ensemble des valeurs décrites par le domaine réaliste~;

\item la {\strong générabilité} qui permet de générer une valeur décrite par le
domaine réaliste.

\end{itemize}

\end{definition}

Ces deux caractéristiques permettent respectivement de {\strong valider} et de
{\strong vérifier} un programme.

\subsection{Implémentation}
\label{subsection:language:realdom:implementation}

Nous proposons une implémentation des domaines réalistes en PHP. Dans cette
implémentation, un domaine réaliste est représenté par une {\strong classe}, et
ses propriétés de prédicabilité et de générabilité par les {\strong méthodes}
respectives suivantes~:

\begin{itemize}

\item \code{predicate(\$q)}, où \code{\$q} est la valeur à valider~;

\item \code{sample(\$sampler)}, où \code{\$sampler} est un {\strong générateur
numérique}~: il génère uniquement des entiers et des réels, et permet de guider
la génération d'une donnée~; par exemple nous allons utiliser ce générateur
numérique pour choisir un caractère parmi une plage de caractères donnés.  Pour
l'instant, le seul générateur numérique disponible est pseudo-aléatoire.

\end{itemize}

\subsection{Hiérarchie}
\label{subsection:language:realdom:hierarchy}

Parce que les domaines réalistes sont implémentés à travers des classes et que
PHP est orienté objet, nous pouvons faire de l'{\strong héritage}. Par
conséquent, un domaine réaliste enfant peut hériter et {\strong raffiner} les
propriétés de son parent. Par exemple, le domaine réaliste \code{Color} hérite
de \code{String}, et \code{Bound\-integer} hérite de \code{Integer}. Une seule
contrainte~: tous les domaines réalistes doivent être enfant de la classe
\code{Realdom}.

\begin{figure}[t]
\begin{bigpre}
class          Boundinteger \\
    extends    Integer                                      /* \(\circled{1}\) */ \\
    implements IRealdom\bslash{}Interval,  IRealdom\bslash{}Finite          /* \(\circled{5}\) */ \\
               IRealdom\bslash{}Nonconvex, IRealdom\bslash{}Enumerable \{ \\
\\
    protected \$_arguments = [ \\
        'Constinteger lower' => PHP_INT_MIN,                /* \(\circled{4}\) */ \\
        'Constinteger upper' => PHP_INT_MAX \\
    ]; \\
\\
    public function predicate ( \$q ) \{ \\
\\
        return    parent::predicate(\$q)                     /* \(\circled{2}\) */ \\
               && \$q >= \$this['lower']->getConstantValue()  /* \(\circled{3}\) */ \\
               && \$q <= \$this['upper']->getConstantValue(); \\
    \} \\
\\
    public function sample ( \$sampler ) \{ \\
\\
        return \$sampler->getInteger( \\
            \$this['lower']->sample(\$sampler), \\
            \$this['upper']->sample(\$sampler) \\
        ); \\
    \} \\
\\
    // … \\
\}
\end{bigpre}

\caption{\label{figure:language:boundinteger} Implémentation légère du domainer
réaliste \code{Boundinteger}.}

\end{figure}

La figure~\ref{figure:language:boundinteger} montre une implémentation légère du
domaine réaliste \code{Bound\-integer}. Il hérite du domaine réaliste
\code{Integer} en \circled{1}. Nous remarquons aussi de nombreux interfaces pour
caractériser la «~forme~» ou les propriétés du domaine réaliste (détaillé dans
la partie \ref{subsection:language:realdom:classification}). La propriété de
prédicabilité raffine celle du parent en \circled{2}, et ajoute de nouvelles
contraintes en \circled{3} qui vérifient que \code{\$q} appartient à
l'intervalle décrit par le domaine réaliste.

\subsection{Paramètres}
\label{subsection:language:realdom:parameters}

{\em A l'instar} des fonctions, les domaines réalistes sont {\strong
paramétrables}.  Les données reçues par le domaine réaliste sont appelées ses
{\strong arguments}. Les paramètres sont très utiles pour représenter des
structures de données complexes, telles que des tableaux imbriqués, des graphes,
des automates, des arbres etc.

\begin{example}[Paramétrer un domaine réaliste]

Par exemple, le domaine réaliste \code{string(0x61, 0x7a, boundinteger(4, 12))}
représente une chaîne de caractères dont la taille est comprise entre 4 et 12 et
dont les code-points des caractères sont entre \code{0x61} et \code{0x7a}. Nous
pouvons écrire \code{4..12}, qui est un sucre syntaxique de
\code{boundinteger(4, 12)}.

\end{example}

Quand nous décrivons les paramètres d'un domaine réaliste, nous pouvons indiquer
leurs types. Le type est exprimé à travers le ou les noms de domaines réalistes,
séparés par le symbole \code{$\vert$}. En effet, un domaine réaliste accepte
plusieurs sortes d'arguments et est capable de faire la traduction d'un domaine
réaliste vers un autre lui-même. Ainsi, nous restons proche de la philosophie de
PHP et de son typage dynamique. La figure~\ref{figure:language:boundinteger}
montre la déclaration de deux paramètres~: \code{lower} et \code{upper} en
\circled{4}, qui sont de type \code{Constinteger}, avec respectivement en valeur
par défaut \code{PHP\_INT\_MIN} et \code{PHP\_INT\_MAX} qui sont des constantes
de PHP. Si aucune valeur par défaut n'est précisée, alors le paramètre est
{\strong obligatoire}, sinon il est {\strong optionnel}.

\begin{example}[Multi-typage des paramètres]

Un exemple de multi-typage de paramètres avec le domaine réaliste \code{String},
dont ses deux premiers paramètres peuvent être des entiers ou des caractères,
déclarés comme suit~:
%
\begin{pre}
protected \$_arguments = [ \\
    'Constinteger|Conststring codepointMin' => 0x20, \\
    'Constinteger|Conststring codepointMax' => 0x7e, \\
    'Integer                  length' \\
];
\end{pre}
%
où \code{Constinteger} et \code{Conststring} représentent respectivement un
entier et une chaîne de caractères Praspel comme \code{7} ou \code{'foo'}.
Alors, nous pouvons écrire \code{string('a', 'z', 4..12)} sans produire
d'erreur, mais \code{string(true, 'z', 4..12)} produira une erreur car
\code{true} est une valeur du domaine réaliste \code{Constboolean} et que le
paramètre \code{codepointMin} n'accepte que les domaines \code{Constinteger} ou
\code{Conststring}.

Nous voyons que les deux premiers paramètres sont optionnels et que seul le
dernier est obligatoire. Pour utiliser la valeur par défaut d'un paramètre, nous
pouvons utiliser le mot-clé \code{default} (ou \code{…}). Ainsi, nous pouvons
écrire~: \code{string(default, default, 7)} (ou \code{string(…, …, 7)}).

Notons également que les chaînes de caractères de Praspel (représentées par le
domaine réaliste \code{Conststring}) sont au format Unicode (UTF-8), ce qui nous
permet d'écrire~: \code{string('$\alpha$', '$\omega$', 4..12)} pour représenter
un mot en minuscule écrit en grec.

\end{example}



\subsection{Classification}
\label{subsection:language:realdom:classification}

L'héritage que nous venons de voir en
\ref{subsection:language:realdom:hierarchy} est une classification. Une autre
classification {\strong transversale} est possible grâce aux {\strong
interfaces}. Elles aident à caractériser le «~paysage~» des domaines réalistes.
Les interfaces les plus intéressantes sont~:

\begin{itemize}

\item \code{Constant}, pour représenter un domaine réaliste immuable avec
seulement une valeur, comme \code{42} (du domaine réaliste \code{Constinteger}),
\code{true} (du domaine réaliste \code{Constboolean}) etc.~;

\item \code{Interval}, pour représenter un intervalle à travers une borne
inférieure et supérieure, qui peuvent être réduites dynamiquement (à
l'exécution)~;

\item \code{Finite}, pour représenter un domaine réaliste avec un ensemble de
valeurs dénombrable~;

\item \code{Nonconvex}, pour représenter un domaine réaliste avec des trous, \ie
où des valeurs ont été exclues, et donc, ne peuvent plus être générées~;

\item \code{Enumerable}, pour représenter un domaine réaliste dont les valeurs
peuvent être énumérées.

\end{itemize}

Ainsi, par exemple, dans la figure~\ref{figure:language:boundinteger} en
\circled{5}, nous voyons que le domaine réaliste \code{Boundinteger} implémente
les interfaces \code{Interval}, \code{Finite}, \code{Nonconvex} et
\code{Enumerable}. C'est donc un intervalle avec un nombre fini d'éléments que
nous pouvons énumérer mais qui peut contenir des trous.
