\def\gsep{$\quad::=\quad$}
\def\mvert{$\;\;|\;\;$}
\newcommand{\token}[1]{\underline{\code{php-#1}}}
\newcommand{\grule}[1]{\textit{#1}}

\section{Praspel}
\label{section:language:praspel}

Praspel est un acronyme anglais signifiant {\em PHP Realistic Annotation and
SPEcification Language}. C'est un langage et un framework de test à partir de
contrats en PHP (voir la
Section~\ref{subsection:language:contract-based_testing}). Ce langage repose
sur les domaines réalistes.

Praspel est un {\em langage d'annotation} car il s'écrit dans les commentaires
du code source du programme. PHP comprend trois catégories de commentaires~: en
ligne (avec \code{//} ou \code{\#}), multi-lignes (entre \code{/*} et \code{*/})
et en bloc (entre \code{/**} et \code{*/}). C'est dans cette dernière catégorie
que nous écrirons Praspel, catégorie qui est culturellement dédiée à l'écriture
des annotations, documentations API etc.

Praspel est un {\em Behavioral Interface Specification Language} (BISL) basé sur
les contrats. Un {\em contrat} est un modèle du comportement du code, décrit à
travers des contraintes formelles, alors appelées clauses, comme les
préconditions, les postconditions et les invariants. Ces contraintes sont
généralement localisées dans le code source autour des données. Dans le cas de
Praspel, les invariants sont localisés sur les attributs des classes et les
préconditions avec les postconditions sont localisées sur les paramètres des
méthodes. La sémantique d'un contrat est la suivante~:

\begin{itemize}

\item l'appelant de la méthode s'engage à satisfaire la précondition~;

\item seulement dans ce cas, la méthode appelée s'engage à satisfaire sa
postcondition~;

\item les invariants, quant à eux, doivent être satisfait avant et après
l'exécution de la méthode.

\end{itemize}

Le reste de la section décrit les parties de la grammaire de Praspel, en forme
normale.

\subsection{Clauses}
\label{subsection:language:clauses}

\begin{figure}
\centering
\begin{tabular}{rcl}
\grule{specification} & \gsep &
    \grule{attribute-clauses} \mvert \grule{method-clauses} \\

\grule{attribute-clauses} & \gsep &
    \grule{invariant-clause}$^?$ \\

\grule{method-clauses} & \gsep &
    $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \grule{rbet-clauses} \\

\grule{rbet-clauses} & \gsep &
    $($ \grule{requires-clause} \code{;} $)^?$ \\ & &
    $($ \\ & &
    $\quad\,\,($ \grule{behavior-clause}$^+$ \grule{default-clause}$^?$ $)^?$ \\ & &
    \mvert $($ \grule{ensures-clause} \code{;} $)^?$
    $($ \grule{throwable-clause} \code{;} $)^?$ \\ & &
    $)$ \\
\end{tabular}

\caption{\label{figure:language:grammar_part0} Grammaire de Praspel en forme
normale~: les entités syntaxiques de plus haut niveau.}

\end{figure}

\begin{figure}
\centering
\begin{tabular}{rcl}
\grule{invariant-clause} & \gsep &
    \ainvariant \grule{expression} \\

\grule{requires-clause} & \gsep &
    \arequires \grule{expression} \\

\grule{behavior-clause} & \gsep &
    \abehavior \token{identifier} \code{\{} \\ & &
    \quad $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \quad \grule{rbet-clauses} \\ & &
    \code{\}} \\

\grule{default-clause} & \gsep &
    \adefault \code{\{} \\ & &
    \quad $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \quad $($ \grule{ensures-clause} \code{;} $)^?$ \\ & &
    \quad $($ \grule{throwable-clause} \code{;} $)^?$ \\ & &
    \code{\}} \\

\grule{ensures-clause} & \gsep &
    \aensures \grule{expression} \\

\grule{throwable-clause} & \gsep &
    \athrowable \grule{exceptional-expression} \\

\grule{description-clause} & \gsep &
    \adescription \token{string} \\
\end{tabular}

\caption{\label{figure:language:grammar_part1} Grammaire de Praspel en forme
normale~: les entités syntaxiques des clauses.}

\end{figure}

Un contrat est composé de clauses, dont la syntaxe est décrite dans les
Figures~\ref{figure:language:grammar_part0},
\ref{figure:language:grammar_part1}, \ref{figure:language:grammar_part2} et
\ref{figure:language:grammar_part3}. Dans ces figures, le style \code{token}
représente un lexème de la grammaire de Praspel, \grule{rule} représente une
entité syntaxique (règle) de la grammaire, et \token{token} représente un lexème
de la grammaire de PHP (pour être le plus proche possible du langage manipulé
par le développeur). La notation $e^r_s$ signifie que le motif $e$ est répété
$r$ fois, et séparé par $s$. $r$ peut être $?$, $+$ ou $*$, respectivement pour
0 ou 1 fois, 1 ou plusieurs fois et 0 ou plusieurs fois. Si $s$ n'est pas vide,
alors $s$ doit être un lexème.

\begin{figure}
\begin{pre}
class \(C\) \{ \\
\\
    /** \\
     * @invariant \(I\); \\
     */ \\
    protected \$a; \\
\\
    /** \\
     * @requires \(R\); \\
     * @behavior \(\alpha\) \{ \\
     *     @requires \(R\sb{\alpha}\); \\
     *     @behavior \(\beta\) \{ \\
     *         @requires  \(R\sb{\alpha.\beta}\); \\
     *         @ensures   \(E\sb{\alpha.\beta}\); \\
     *         @throwable \(T\sb{\alpha.\beta}\); \\
     *     \} \\
     * \} \\
     * @behavior \(\gamma\) \{ \\
     *     @requires \(R\sb{\gamma}\); \\
     *     \(\dots\) \\
     * \} \\
     * @default \{ \\
     *     @ensures   \(E\sb{\m{D}}\); \\
     *     @throwable \(T\sb{\m{D}}\); \\
     * \} \\
     */ \\
    public function f ( ) \{ \} \\
\}
\end{pre}

\caption{\label{figure:language:typical_contract} Un contrat Praspel typique
avec toutes les clauses.}

\end{figure}

Les entités syntaxiques \grule{attribute-clauses} et \grule{method-clauses} de
la Figure~\ref{figure:language:grammar_part0} définissent respectivement les
clauses annotant les attributs d'une classe et ses méthodes. Toutes ces clauses
introduisent des expressions Praspel, détaillées dans la
Section~\ref{subsection:language:expressions}. L'entité syntaxique
\grule{method-clauses} montre l'ordre des clauses en forme normale. La grammaire
actuelle de Praspel est bien plus libérale~: elle accepte des clauses dans
n'importe quel ordre mais pour faciliter le raisonnement, nous ne présenterons
et ne travaillerons que sur une forme normale.

La Figure~\ref{figure:language:typical_contract} montre un contrat sous sa forme
la plus typique~: une classe \code{C} avec un attribut \code{a} et une méthode
\code{f}. La clause \ainvariant est localisée juste avant l'attribute \code{a}.
Les invariants sont vérifiés avant et après l'exécution du système. Les autres
clauses sont des clauses de méthode. Elles sont localisées juste avant l'en-tête
des méthodes.

La précondition d'une méthode est exprimée à l'aide de la clause \arequires, la
postcondition à l'aide de la clause \aensures. La précondition exprime des
contraintes sur le pré-état du système, alors que la postcondition exprime des
contraintes sur le post-état du système. Afin de modifier l'état du système, il
doit être exécuté en appelant une méthode. La clause \aensures représente une
postcondition normale, mais le système peut aussi lever une exception et être
alors placé dans un post-état exceptionnel. La clause \athrowable exprime des
contraintes sur cet état particulier~: elle exprime les conditions sous
lesquelles des exceptions peuvent être levées par la méthode et aussi le
post-état du système associé (par exemple une exception a été levée mais le
système est suffisamment propre pour tenter une nouvelle exécution). La syntaxe
de $T$ ($T_{\alpha.\beta}$ et $T_\m{D}$) dans la
Figure~\ref{figure:language:typical_contract} est définie par l'entité
syntaxique \grule{exceptional-expression} dans la
Figure~\ref{figure:language:grammar_part2}. $T$ peut être \code{$T_C$ with
$T_E$}, où $T_C$ est une liste de nom de classes asssociée à un identifiant, et
$T_E$ est une expression, appelée {\em postcondition exceptionnelle}, dont la
syntaxe est détaillée dans la Section~\ref{subsection:language:expressions}.
Tous les identifiants définis dans $T_C$ peuvent apparaître dans $T_E$. La
sémantique est la suivante~: si l'exception levée est une instance d'une classe
représentant une exception listée dans $T_C$, alors elle est assignée à
l'identifiant associée et la postcondition exceptionnelle $T_E$ doit être
satisfaite.

Une méthode peut avoir différents comportements relatifs à ses arguments et
l'état du système. Praspel propose la clause \abehavior pour représenter un
comportement, identifié par un nom, et peut potentiellement contenir une
description informelle, grâce à la clause \adescription~; ces deux informations
peuvent s'avérer très utiles pour offrir un retour à l'utilisateur. Les clauses
\arequires, \aensures, \athrowable et \abehavior elle-même peuvent apparaître à
l'intérieur d'une clause \abehavior. Cette structure décrit des comportements
imbriqués, comme illustré dans la Figure~\ref{figure:language:typical_contract}
dans laquelle le comportement $\beta$ est imbriqué dans le comportement
$\alpha$. À côté de ça, nous pouvons également décrire des comportements
alternatifs en juxtaposant des clauses \abehavior. Ceci est toujours illustré
dans la Figure~\ref{figure:language:typical_contract} avec le comportement
$\gamma$, frère du comportement $\alpha$. Les comportements sont, dans la
pratique, mutuellement exclusifs. Cependant, la syntaxe autorise l'écriture de
comportement non-déterministe.

Afin d'«~activer~» un comportement donné, sa clause \arequires doit être
satisfaite. La clause \adefault est strictement équivalente à une clause
\abehavior avec une clause \arequires implicite décrivant la conjonction de
toutes les négations des clauses \arequires des comportements frères précédents.

Après l'exécution, le système est dans le post-état. Nous faisons face à deux
situations. Si c'est un post-état normal, alors la clause \aensures du
comportement courant doit être satisfaite. Si c'est un post-état exceptionel,
alors la clause \athrowable doit être satisfaite, \ie les deux $T_C$ et $T_E$
doivent être satisfait, comme décrit précédemment.

\subsection{Expressions}
\label{subsection:language:expressions}

Les Figures~\ref{figure:language:grammar_part2} et
\ref{figure:language:grammar_part3} décrivent les expressions Praspel. Nous
avons principalement trois sortes d'expressions~: déclarations, prédicats et
contraintes, respectivement présentées dans les paragraphes suivants.

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
\grule{expression} & \gsep &
  (\grule{declaration}$^+_\code{and}$ $\code{and})^?$ \\ & &
  (\grule{constraint}$^+_\code{and}$ $\code{and})^?$  \\ & &
   \grule{predicate}$^?_\code{and}$ \\

\grule{exceptional-expression} & \gsep &
    $($ $($ \grule{exception-identifier} $)^+_\code{or}$
    \code{with} \grule{expression} $)^+_{\code{or}}$ \\

\grule{exception-identifier} & \gsep &
    \token{classname} \token{identifier} \\
\end{tabular}
\end{center}

\caption{\label{figure:language:grammar_part2} Grammaire de Praspel en forme
normale~: les entités syntaxiques d'expressions.}

\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
\grule{declaration} & \gsep &
    \code{let}$^?$ \grule{extended-identifier} \code{:} \grule{disjunction} \\

\grule{constraint} & \gsep &
    \grule{qualification} \mvert \grule{contains} \\

\grule{qualification} & \gsep &
    \grule{identifier} \code{is} \token{identifier}$^+_\code{,}$ \\

\grule{contains} & \gsep &
    \grule{extended-identifier} \code{contains} \grule{constant}$^+_\code{or}$ \\

\grule{predicate} & \gsep &
    \code{\bslash pred(} \token{string} \code{)} \\

\grule{disjunction} & \gsep &
    $($
    \grule{constant} \mvert \grule{realdom} \mvert \grule{extended-identifier}
    $)^+_\code{or}$ \\

\grule{realdom} & \gsep &
    \token{identifier} \code{(} \grule{argument}$^?_\code{,}$ \code{)} \\

\grule{argument} & \gsep &
    \code{default} \mvert \grule{realdom} \mvert \grule{constant} \mvert
    \grule{array} \\ & &
    \mvert \grule{extended-identifier} \\

\grule{constant} & \gsep &
    \grule{scalar} \mvert \grule{array} \\

\grule{scalar} & \gsep &
    \code{null} \mvert \token{boolean} \mvert \grule{number} \mvert
    \token{string} \\

\grule{number} & \gsep &
    \token{binary} \mvert \token{octal} \mvert \token{hexa} \mvert
    \token{decimal} \\

\grule{array} & \gsep &
    \code{[} \grule{pair}$^?_\code{,}$ \code{]} \\

\grule{pair} & \gsep &
    \code{from}$^?$ \grule{disjunction} \code{to} \grule{disjunction} \\ & &
    \mvert \code{to}$^?$ \grule{disjunction} \\

\grule{extended-identifier} & \gsep &
    \grule{array-access} \\

\grule{array-access} & \gsep &
    \grule{identifier} $($ \code{[} \grule{scalar} \code{]} $)^?$ \\

\grule{identifier} & \gsep &
    \token{identifier} \\ & &
    \mvert \code{this} $($ \code{->} \token{identifier} $)^*$ \\ & &
    \mvert $($ \code{self} \mvert \code{static} \mvert \code{parent} $)$
    $($ \code{::} \token{identifier} $)^+$ \\ & &
    \mvert \code{\bslash old(} \grule{extended-identifier} \code{)} \\ & &
    \mvert \code{\bslash result} \\
\end{tabular}
\end{center}

\caption{\label{figure:language:grammar_part3} Grammaire de Praspel en forme normale~:
entités syntaxiques de construction des expressions.}

\end{figure}

\begin{figure}
\begin{pre}
/** \\
 * \arequires seed:   7..42 or 153..256 and \\
 *           factor: 1.0.. and \\
 *           \(\bslash\)pred('isfemtotime() or isarch(64)'); \\
 * \aensures  \(\bslash\)result: array([to float()], 1..5); \\
 */ \\
public function generate ( \$seed, \$factor ) \{ ... \}
\end{pre}

\caption{\label{figure:language:short_contract} Exemple d'un court contrat.}

\end{figure}

\paragraph{Déclarations.} Une déclaration assigne un ou plusieurs domaines
réalistes à une variable à travers l'opérateur \code{:}. Une variable est soit
un attribut de classe, spécifié dans une clause \ainvariant, soit un paramètre
de la méthode, spécifié dans les autres clauses. La valeur d'une variable peut
appartenir à différent domaines réalistes si la variable est définie par une
{\em disjonction} de domaines réalistes, représentée par le mot-clé \code{or}.
La Figure~\ref{figure:language:short_contract} représente un court contrat
contenant seulement une précondition (\arequires) et une postcondition
(\aensures). Cette figure présente la variable \code{seed}, dont le domaine
réaliste est soit une intervalle entre 7 et 42, soit un intervalle entre 153 et
256, et la variable \code{factor} avec un seul domaine réaliste qui est un réel
supérieur ou égal à 1.0 (représenté par un intervalle de réels avec une seule
borne inférieure 1.0~—~le sucre syntaxique \code{1.2..3.4} est équivalent à
\code{boundfloat(1.2, 3.4)}~—). Une disjonction de domaines réalistes peut
contenir n'importe quelle sorte de domaine réaliste~: ce afin de mimer l'aspect
dynamique de PHP.

Si une variable est précédée par le mot-clé \code{let}, cela signifie que c'est
une variable locale, qui appartient au modèle et non pas au système. C'est très
utile pour manipuler des représentations intermédiaires de données.

La clause \aensures a une particularité~: elle peut contenir la variable
spéciale \aresult qui représente la valeur retournée par la méthode. Les clauses
\aensures et \athrowable peuvent également faire référence à la valeur d'une
variable dans le pré-état grâce à la construction \aold{i}, où $i$ est le nom
d'une variable.

\paragraph{Prédicats.} Toutes les constructions présentent dans Praspel
supportent la validation et la vérification, \ie par les propriétés de
prédicabilité et de générabilité des domaines réalistes. Chaque concept
introduit dans le langage doit supporter ces deux aspects. Mais ils arrivent que
certaines choses ne puissent pas être exprimées avec les constructions
actuelles. C'est pourquoi nous avons la construction «~boîte-noire~» \apred{p},
où $p$ est du code PHP. Cette construction permet à l'utilisateur d'exprimer des
contraintes arbitraites en utilisant PHP lui-même au lieu de Praspel. Le code
$p$ doit être un prédicat en forme normal disjonctive (DNF). La construction
\apred{\empty} ne supporte que la validation (prédicabilité) et non pas la
vérification (générabilité). Le prédicat \apred{\code{'isfemtotime() or
isarch(64)'}} dans la Figure~\ref{figure:language:short_contract} signifie que
si le système supporte le temps femto (une variante du temps micro) ou si
l'architecture est en 64~bits, alors cette partie de la précondition est
satisfaite.

Parce que la construction \apred{\empty} est une boîte-noire, elle introduit du
rejet lors de la génération de données. En effet, quand nous générons des
données, nous les validons auprès des prédicats. Si un prédicat est trop fort,
il invalide la donnée, et nous en générons de nouvelles. Une telle situation
peut conduire à une boucle infinie. Heureusement, il existe un nombre maximum
d'essais (qui est paramétrable). Quand ce nombre est atteint, le générateur
abandonne.

Une tâche récurrente est d'observer et analyser ce que les utilisateurs écrivent
le plus dans cette construction, et l'extraire dans Praspel afin de supporter
les deux aspects~: validation et vérification. L'objectif est de faire évoluer
le langage en supportant plus de constructions usuelles nativement au lieu de
les avoir dans une boîte-noire, et ainsi, entre autre, réduire le rejet lors de
la génération de données. Ce processus est illustré dans la
Section~\ref{section:data:arrays}.

\paragraph{Contraintes.} Praspel a principalement deux sortes de contraintes~:
soit en utilisant la syntaxe des déclarations, soit en utilisant le mot-clé
\code{is}. Des exemples de contraintes sont présentées dans la
Section~\ref{section:data:arrays}.
