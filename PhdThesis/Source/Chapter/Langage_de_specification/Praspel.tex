\def\gsep{$\quad::=\quad$}
\def\mvert{$\;\;|\;\;$}
\def\mvertp{\phantom{$\;\;|\;\;$}}
\newcommand{\gtoken}[1]{\underline{\code{php-#1}}}
\newcommand{\grule}[1]{\textit{#1}}

\section{Praspel}
\label{section:language:praspel}

Praspel est un acronyme anglais signifiant \inenglish{PHP Realistic Annotation
and SPEcification Language}. C'est un langage et un framework de test à partir
de contrats en PHP. Ce langage {\strong repose} sur les domaines réalistes.

Praspel est un {\strong langage d'annotation} car il s'écrit dans les
commentaires du code source du programme. PHP comprend trois catégories de
commentaires~: en ligne (avec \code{//} ou \code{\#}), multi-lignes (entre
\code{/*} et \code{*/}) et en bloc (entre \code{/**} et \code{*/}). C'est dans
cette dernière catégorie que nous écrirons Praspel, catégorie qui est
culturellement dédiée à l'écriture des annotations, documentations API etc.

Praspel est un \inenglish{Behavioral Interface Specification Language} ({\strong
BISL}) basé sur les contrats. Un {\strong contrat} est un modèle du comportement
du code, décrit à travers des contraintes formelles, alors appelées {\strong
clauses}, comme les préconditions, les postconditions et les invariants. Ces
contraintes sont généralement localisées dans le code source autour des données.
Dans le cas de Praspel, les invariants sont localisés sur les attributs des
classes et les préconditions avec les postconditions sont localisées sur les
paramètres des méthodes. La sémantique d'un contrat est la suivante~:

\begin{itemize}

\item l'appelant de la méthode s'engage à satisfaire la précondition~;

\item seulement dans ce cas, la méthode appelée s'engage à satisfaire sa
postcondition~;

\item les invariants, quant à eux, doivent être satisfait avant et après
l'exécution de la méthode.

\end{itemize}

Nous décrivons maintenant les parties de la grammaire de Praspel en forme
normale. La grammaire complète se trouve dans
l'annexe~\ref{appendices:grammar_of_praspel}
page~\pageref{appendices:grammar_of_praspel}.

\subsection{Clauses}
\label{subsection:language:clauses}

\begin{figure}
\centering
\begin{tabular}{rcl}
\grule{specification} & \gsep &
    \grule{attribute-clauses} \mvert \grule{method-clauses} \\

\grule{attribute-clauses} & \gsep &
    \grule{invariant-clause}$^?$ \\

\grule{method-clauses} & \gsep &
    $($ \grule{is-clause} \code{;} $)^?$ \\ & &
    $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \grule{rbdet-clauses} \\

\grule{rbdet-clauses} & \gsep &
    $($ \grule{requires-clause} \code{;} $)^?$ \\ & &
    $($ \\ & &
    $\quad\,\,($ \grule{behavior-clause}$^+$ \grule{default-clause}$^?$ $)^?$ \\ & &
    \mvert $($ \grule{ensures-clause} \code{;} $)^?$
    $($ \grule{throwable-clause} \code{;} $)^?$ \\ & &
    $)$ \\
\end{tabular}

\caption{\label{figure:language:grammar_part0} Grammaire de Praspel en forme
normale~: les entités syntaxiques de plus haut niveau.}

\end{figure}

Un contrat est composé de clauses, dont la syntaxe est décrite dans les
figures~\ref{figure:language:grammar_part0},
\ref{figure:language:grammar_part1}, \ref{figure:language:grammar_part2} et
\ref{figure:language:grammar_part3}. Dans ces figures, le style \code{token}
représente un lexème de la grammaire de Praspel, \grule{rule} représente une
entité syntaxique (règle) de la grammaire, et \gtoken{token} représente un lexème
de la grammaire de PHP (pour être le plus proche possible du langage manipulé
par le développeur). La notation $e^r_s$ signifie que le motif $e$ est répété
$r$ fois, et séparé par $s$. $r$ peut être $?$, $+$ ou $*$, respectivement pour
0 ou 1 fois, 1 ou plusieurs fois et 0 ou plusieurs fois. Si $s$ n'est pas vide,
alors $s$ doit être un lexème.

\begin{figure}
\begin{bigpre}
class C \{ \\
\\
    /** \\
     * @invariant \(I\); \\
     */ \\
    protected \$a; \\
\\
    /** \\
     * @is \(S\); \\
     * @requires \(P\); \\
     * @behavior \(\alpha\) \{ \\
     *     @description 'Apply the \(\alpha\) process.'; \\
     *     @requires \(P\sb{\alpha}\); \\
     *     @behavior \(\beta\) \{ \\
     *         @requires  \(P\sb{\alpha.\beta}\); \\
     *         @ensures   \(Q\sb{\alpha.\beta}\); \\
     *         @throwable \(T\sb{\alpha.\beta}\); \\
     *     \} \\
     * \} \\
     * @behavior \(\gamma\) \{ \\
     *     @requires \(P\sb{\gamma}\); \\
     *     \(\dots\) \\
     * \} \\
     * @default \{ \\
     *     @description 'Apply the fallback process.'; \\
     *     @ensures   \(Q\sb{\m{D}}\); \\
     *     @throwable \(T\sb{\m{D}}\); \\
     * \} \\
     */ \\
    public function f ( ) \{ \} \\
\}
\end{bigpre}

\caption{\label{figure:language:typical_contract} Un contrat Praspel typique
avec toutes les clauses.}

\end{figure}

La figure~\ref{figure:language:grammar_part0} montre les familles de clauses,
dont le contenu est décrit par la figure~\ref{figure:language:grammar_part1}.
Ainsi, nous apprenons que les entités syntaxiques \grule{attribute-clauses} et
\grule{method-clauses} définissent respectivement les clauses annotant les
attributs d'une classe et ses méthodes.  L'entité syntaxique
\grule{method-clauses} montre l'ordre des clauses en forme normale. La grammaire
actuelle de Praspel est bien plus libérale~: elle accepte des clauses dans
n'importe quel ordre mais pour faciliter le raisonnement, nous ne présenterons
et ne travaillerons que sur une forme normale. La
figure~\ref{figure:language:typical_contract} illustre la localisation typique
des clauses sur une classe \code{C} avec un attribut \code{a} et une méthode
\code{f}. La clause \ainvariant est localisée juste avant l'attribut \code{a}.
Les autres clauses sont des clauses de méthode.  Elles sont localisées juste
avant l'en-tête des méthodes. La plupart de ces clauses introduisent des
expressions Praspel, représentée par les entités syntaxiques \grule{expression}
ou \grule{exceptional-expression}, détaillées dans la
partie~\ref{subsection:language:expressions}.

\begin{figure}
\centering
\begin{tabular}{rcl}
\grule{invariant-clause} & \gsep &
    \ainvariant \grule{expression} \\

\grule{requires-clause} & \gsep &
    \arequires \grule{expression} \\

\grule{behavior-clause} & \gsep &
    \abehavior \gtoken{identifier} \code{\{} \\ & &
    \quad $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \quad \grule{rbdet-clauses} \\ & &
    \code{\}} \\

\grule{default-clause} & \gsep &
    \adefault \code{\{} \\ & &
    \quad $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \quad $($ \grule{ensures-clause} \code{;} $)^?$ \\ & &
    \quad $($ \grule{throwable-clause} \code{;} $)^?$ \\ & &
    \code{\}} \\

\grule{ensures-clause} & \gsep &
    \aensures \grule{expression} \\

\grule{throwable-clause} & \gsep &
    \athrowable \grule{exceptional-expression} \\

\grule{is-clause} & \gsep &
    \ais \code{pure} \\

\grule{description-clause} & \gsep &
    \adescription \gtoken{string} \\
\end{tabular}

\caption{\label{figure:language:grammar_part1} Grammaire de Praspel en forme
normale~: les entités syntaxiques des clauses.}

\end{figure}

La précondition d'une méthode est exprimée à l'aide de la clause \arequires, la
postcondition à l'aide de la clause \aensures. La précondition exprime des
contraintes sur le {\strong pré-état} du système, alors que la postcondition
exprime des contraintes sur le {\strong post-état} du système. Afin de modifier
l'état du système, il doit être exécuté en appelant une méthode. La clause
\aensures représente une {\strong postcondition normale}, mais le système peut
aussi lever une exception et être alors placé dans un {\strong post-état
exceptionnel}. La clause \athrowable exprime des contraintes sur cet état
particulier~: elle exprime les conditions sous lesquelles des exceptions peuvent
être levées par la méthode et aussi le post-état du système associé (par exemple
une exception a été levée mais le système est suffisamment propre pour tenter
une nouvelle exécution). La syntaxe de $T$ ($T_{\alpha.\beta}$ et $T_\m{D}$ dans
la figure~\ref{figure:language:typical_contract}) est définie par l'entité
syntaxique \grule{exceptional-expression} dans la
figure~\ref{figure:language:grammar_part2}. $T$ peut être \code{$T_C$ with
$T_E$}, où $T_C$ est une liste de nom de classes asssociée à un identifiant, et
$T_E$ est une expression, appelée {\strong postcondition exceptionnelle}, dont
la syntaxe est détaillée dans la partie~\ref{subsection:language:expressions}.
Tous les identifiants définis dans $T_C$ peuvent apparaître dans $T_E$. La
sémantique est la suivante~: si l'exception levée est une instance d'une classe
représentant une exception listée dans $T_C$, alors elle est assignée à
l'identifiant associée et la postcondition exceptionnelle $T_E$ doit être
satisfaite.

Une méthode peut avoir différents {\strong comportements} relatifs à ses
arguments et l'état du système. Praspel propose la clause \abehavior pour
représenter un comportement, identifié par un nom, et peut potentiellement
contenir une description informelle, grâce à la clause \adescription~; ces deux
informations peuvent s'avérer très utiles pour offrir un retour à l'utilisateur.
Les clauses \arequires, \aensures, \athrowable et \abehavior elle-même peuvent
apparaître à l'intérieur d'une clause \abehavior. Cette structure décrit des
comportements {\strong imbriqués}, comme illustré dans la
figure~\ref{figure:language:typical_contract} dans laquelle le comportement
$\beta$ est imbriqué dans le comportement $\alpha$. À côté de ça, nous pouvons
également décrire des comportements {\strong alternatifs} en juxtaposant des
clauses \abehavior. Ceci est toujours illustré dans la
figure~\ref{figure:language:typical_contract} avec le comportement $\gamma$,
frère du comportement $\alpha$. Les comportements sont, dans la pratique,
{\strong mutuellement exclusifs}, cependant, la syntaxe autorise l'écriture de
comportement non-déterministe.

La clause \adefault est strictement équivalente à une clause \abehavior avec une
clause \arequires implicite décrivant la conjonction de toutes les négations des
clauses \arequires des comportements frères précédents.  Par exemple, dans la
figure~\ref{figure:language:typical_contract} la clause \arequires de \adefault
pourrait mathématiquement s'écrire $\neg P_\alpha \land \neg P_\gamma$.

Afin d'«~activer~» un comportement donné, sa clause \arequires doit être
satisfaite. Après l'exécution, le système est dans le post-état. Nous faisons
face à deux situations. Si c'est un post-état normal, alors la clause \aensures
du dernier comportement activé doit être satisfaite. Si c'est un post-état
exceptionel, alors c'est la clause \athrowable qui doit être satisfaite, \ie les
deux $T_C$ et $T_E$ doivent être satisfaits, comme décrit précédemment.

Enfin, la clause \ais permet de qualifier la catégorie de la méthode. Le seul
qualificatif actuel est \code{pure}, pour contrôler la mutabilité de
l'environnement. En effet, une méthode peut muter (modifier) ou pas son
environnement lors de son exécution. Si elle ne le modifie pas, alors nous
parlons d'une méthode {\strong pure}, sinon nous parlons d'une méthode {\strong
mutante} (par défaut). Seules les méthodes pures peuvent être utilisées dans les
contrats. \\

\begin{figure}
\begin{bigpre}
class Filesystem \{ \\
\\
    const SIZE = 1024; \\
\\
    /** \\
     * @invariant _usage: boundinteger(0, static::SIZE); \\
     */ \\
    protected \$_usage = 0; \\
\\
    /** \\
     * @invariant _map: array([to class('File')], 0..0xffff); \\
     */ \\
    protected \$_map = array(); \\
\\
    /** \\
     * @is pure; \\
     * @ensures \(\bslash\)result: this->_usage; \\
     */ \\
    public function getUsage ( ) \{ /* … */ \} \\
\\
    /** \\
     * @requires file: class('File') and \\
     *           index: 0..0xffff or void; \\
     * @behavior full \{ \\
     *     @description 'The filesystem is full.'; \\
     *     @requires  \(\bslash\)pred('\$this->getUsage() + \$file->getSize() \\
     *                          > static::SIZE'); \\
     *     @throwable AllocationException e with \\
     *                    file->isAttached(): false and \\
     *                    e->getFilesystem(): this; \\
     * \} \\
     * @default \{ \\
     *     @ensures file->isAttached(): true and \\
     *              \(\bslash\)result: boolean(); \\
     * \} \\
     */ \\
    public function store ( File \$file, \$index = null ) \{ /* … */ \} \\
\}
\end{bigpre}

\caption{\label{figure:language:short_contract} Exemple d'une classe
\code{Filesystem} annotée par des contrats.}

\end{figure}

La figure~\ref{figure:language:short_contract} montre un exemple concret d'une
classe \code{Filesystem} annotée, avec deux méthodes \code{getUsage} et
\code{store}. Cet exemple sera utilisé pour illustrer chaque notion introduite
dans la suite de cette partie.

La méthode \code{getUsage} est déclarée comme \code{pure}, ce qui veut dire
qu'elle ne modifie pas son environnement. Elle n'a pas de clause \arequires,
donc elle refusera tous les arguments. Elle a une postcondition, nous y
reviendrons. La méthode \code{store} a deux comportements~: un comportement
\code{full} quand le système de fichier est plein, et un comportement par
défaut. Le premier comportement décrit une précondition et une postcondition
uniquement exceptionnelle. En l'absence de postcondition normale, toute valeur
retournée sera invalide. Ici, seule l'exception \code{AllocationException} peut
être levée. Elle sera associée à l'identifiant \code{e}, puis le reste de la
clause devra être valide. Dans le second comportement (par défaut), aucune
exception ne peut être levée car la clause \athrowable est absente. Nous pouvons
voir également que les attributs \code{\_usage} et \code{\_map} sont annotés
d'invariants avec la clause \ainvariant.

\subsection{Expressions}
\label{subsection:language:expressions}

Les figures~\ref{figure:language:grammar_part2} et
\ref{figure:language:grammar_part3} décrivent les expressions Praspel. Nous
avons principalement trois sortes d'expressions~: déclarations, prédicats et
contraintes, respectivement présentées dans les paragraphes suivants.

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
\grule{expression} & \gsep &
  (\grule{declaration}$^+_\code{and}$ $\code{and})^?$ \\ & &
  (\grule{constraint}$^+_\code{and}$ $\code{and})^?$  \\ & &
   \grule{predicate}$^?_\code{and}$ \\

\grule{exceptional-expression} & \gsep &
    $($ $($ \grule{exception-identifier} $)^+_\code{or}$ \\ & &
    \code{with} \grule{expression} $)^+_{\code{or}}$ \\

\grule{exception-identifier} & \gsep &
    \gtoken{classname} \gtoken{identifier} \\
\end{tabular}
\end{center}

\caption{\label{figure:language:grammar_part2} Grammaire de Praspel en forme
normale~: les entités syntaxiques d'expressions.}

\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
\grule{declaration} & \gsep &
    \code{let}$^?$ \grule{extended-identifier} \code{:} \grule{disjunction} \\

\grule{constraint} & \gsep &
    \grule{qualification} \mvert \grule{contains} \\

\grule{qualification} & \gsep &
    \grule{identifier} \code{is} \gtoken{identifier}$^+_\code{,}$ \\

\grule{contains} & \gsep &
    \grule{extended-identifier} \code{contains} \grule{constant}$^+_\code{or}$ \\

\grule{predicate} & \gsep &
    \code{\bslash pred(} \gtoken{string} \code{)} \\

\grule{disjunction} & \gsep &
    $($
    \grule{constant} \mvert \grule{realdom} \mvert \grule{extended-identifier}
    $)^+_\code{or}$ \\

\grule{realdom} & \gsep &
    \gtoken{identifier} \code{(} \grule{argument}$^?_\code{,}$ \code{)} \\

\grule{argument} & \gsep &
    \code{default} \mvert \grule{realdom} \mvert \grule{constant} \mvert
    \grule{array} \\ & &
    \mvert \grule{extended-identifier} \\

\grule{constant} & \gsep &
    \grule{scalar} \mvert \grule{array} \\

\grule{scalar} & \gsep &
    \code{null} \mvert \gtoken{boolean} \mvert \grule{number} \\ & &
    \mvert \gtoken{string} \\

\grule{number} & \gsep &
    \gtoken{binary} \mvert \gtoken{octal} \mvert \gtoken{hexa} \\ & &
    \mvert \gtoken{decimal} \\

\grule{array} & \gsep &
    \code{[} \grule{pair}$^?_\code{,}$ \code{]} \\

\grule{pair} & \gsep &
    \code{from}$^?$ \grule{disjunction} \code{to} \grule{disjunction} \\ & &
    \mvert \code{to}$^?$ \grule{disjunction} \\

\grule{extended-identifier} & \gsep &
    \grule{array-access} \\

\grule{array-access} & \gsep &
    \grule{identifier} $($ \code{[} \grule{scalar} \code{]} $)^?$ \\

\grule{identifier} & \gsep &
    \gtoken{identifier} \\ & &
    \mvert \code{this} $($ \code{->} \gtoken{identifier} $)^*$ \\ & &
    \mvert $($ \code{self} \mvert \code{static} \mvert \code{parent} $)$ \\ & &
    \mvertp $($ \code{::} \gtoken{identifier} $)^+$ \\ & &
    \mvert \code{\bslash old(} \grule{extended-identifier} \code{)} \\ & &
    \mvert \code{\bslash result} \\
\end{tabular}
\end{center}

\caption{\label{figure:language:grammar_part3} Grammaire de Praspel en forme normale~:
entités syntaxiques de construction des expressions.}

\end{figure}

\subsubsection{Déclarations}

Une déclaration assigne un ou plusieurs domaines réalistes à une variable à
travers l'opérateur \code{:}. Une variable est soit un attribut de classe,
spécifié dans une clause \ainvariant, soit un paramètre de la méthode, spécifié
dans les autres clauses. La valeur d'une variable peut appartenir à plusieurs
domaines réalistes si la variable est définie par une {\strong disjonction} de
domaines réalistes, représentée par le mot-clé \code{or}. Dans la
figure~\ref{figure:language:short_contract}, la variable \code{index} du contrat
de la méthode \code{store} peut avoir deux valeurs~: soit un entier entre 0 et
65535, soit \code{null}. Une disjonction de domaines réalistes peut contenir
n'importe quelle sorte de domaine réaliste~: ce afin de mimer l'aspect dynamique
de PHP.

Si une variable est précédée par le mot-clé \code{let}, cela signifie que c'est
une variable {\strong locale}, qui appartient au modèle et non pas au système
(attribut de classe ou paramètre d'une méthode). C'est très utile pour
manipuler des représentations intermédiaires de données.

La clause \aensures a une particularité~: elle peut contenir la variable
spéciale \aresult qui représente la valeur {\strong retournée} par la méthode.
Les clauses \aensures et \athrowable peuvent également faire {\strong référence}
à la valeur d'une variable dans le pré-état grâce à la construction \aold{i}, où
$i$ est le nom d'une variable.

\subsubsection{Prédicats}

Toutes les constructions présentent dans Praspel supportent la validation et la
vérification, \ie par les propriétés de prédicabilité et de générabilité des
domaines réalistes. Chaque concept introduit dans le langage doit supporter ces
deux aspects. Mais ils arrivent que certaines choses ne puissent pas être
exprimées avec les constructions actuelles. C'est pourquoi nous avons la
construction «~boîte-noire~» \apred{p}, où $p$ est du code PHP. Cette
construction permet à l'utilisateur d'exprimer des contraintes arbitraires en
utilisant PHP lui-même au lieu de Praspel. Le code $p$ doit être un prédicat en
forme normal {\strong conjonctive} (CNF). La construction \apred{p} ne supporte
que la validation (prédicabilité) et non pas la vérification (générabilité). Le
prédicat \apred{\code{'\$this->getUsage() + \$file->getSize() > static::SIZE'}}
dans la figure~\ref{figure:language:short_contract} signifie que s'il n'y a plus
de place pour ajouter un nouveau fichier, alors cette partie de la précondition
est satisfaite.

Parce que la construction \apred{p} est une boîte-noire, elle introduit du rejet
lors de la génération de données car les contraintes $p$ ne sont pas
considérées. En effet, quand nous générons des données, nous les validons auprès
des prédicats. Si un prédicat est trop fort, il invalide la donnée, et nous en
générons de nouvelles. Une telle situation peut conduire à une boucle infinie.
Heureusement, il existe un nombre maximum d'essais (qui est paramétrable). Quand
ce nombre est atteint, le générateur abandonne et émet une erreur qui sera
journalisée.

Une tâche récurrente est d'observer et analyser ce que les utilisateurs écrivent
le plus dans cette construction, et l'extraire dans Praspel afin de supporter
les deux aspects~: validation et vérification. L'objectif est de faire évoluer
le langage en supportant plus de constructions usuelles nativement au lieu de
les avoir dans une boîte-noire, et ainsi, entre autre, réduire le rejet lors de
la génération de données. Ce processus est illustré dans la
partie~\ref{section:data:arrays} page~\pageref{section:data:arrays}.

\subsubsection{Contraintes}

Praspel a principalement deux sortes de contraintes~: soit en utilisant la
syntaxe des déclarations, soit en utilisant le mot-clé \code{is} (différent de
la clause \ais). Des exemples de contraintes sont présentées dans la
partie~\ref{section:data:arrays} page~\pageref{section:data:arrays}.

\subsubsection{Identifiants}

Un mot sur les identifiants. Dans la figure~\ref{figure:language:short_contract}
ainsi que dans la règle \grule{identifier} de la grammaire de la
figure~\ref{figure:language:grammar_part3}, nous pouvons voir l'utilisation de
mot-clés comme \code{this}, \code{self} etc. Pour faire référence à un
identifiant sur un objet, nous utiliserons \code{this}. Pour faire référence à
la classe courante, nous utiliserons \code{self}, pour la classe parente, nous
utiliserons \code{parent}. Et pour faire référence à l'enfant courant d'une
classe, nous utiliserons \code{static}. Par exemple, si nous créons la classe
\code{BigFilesystem} qui hérite de \code{Filesystem} et redéfinit la constante
\code{SIZE}, alors dans \code{Filesystem}, utiliser \code{self::SIZE} sera
équivalent à \code{Filesystem::SIZE} alors que \code{static::SIZE} sera
équivalent à \code{BigFilesystem::SIZE}.

\subsection{Description de tableaux}
\label{subsection:language:array}

La description de tableaux est une partie très important de Praspel, contrôlant
la génération de collections présentée dans la
partie~\ref{section:data:arrays}.

Dans PHP, un tableau est toujours un {\strong tableau associatif} (ou une
\inenglish{map}, un {\strong dictionnaire}), \ie une collection de paires
clé-valeur, où chaque clé apparaît au maximum une fois. Les clés peuvent être de
type nul, booléen, entier, réel ou chaîne de caractères. PHP accepte ces types
de clés mais les booléens sont transtypés en entier et les réels sont réduits à
leur partie entière. Les valeurs quant à elles peuvent être de n'importe quel
type. Un tableau peut être {\strong homogène} ou {\strong hétérogène}. Dans un
tableau homogène, toutes les clés ont le même type, ainsi que toutes les
valeurs. Dans un tableau hétérogène, les clés peuvent avoir des types distincts,
tout comme les valeurs.  Les clés peuvent être {\strong auto-incrémentées}, en
ajoutant 1 à la dernière clé entière, à partir de 0. La {\strong longueur} (ou
la {\strong taille}) d'un tableau est son nombre de paires. Un tableau n'a pas
de longueur prédéfinie, mais sa longueur (stockée en interne par le moteur PHP)
peut être connu grâce à la fonction PHP \code{count()}. Un tableau n'a également
pas de profondeur prédéfinie, \ie il peut contenir un nombre arbitraire de
sous-tableaux.

Dans Praspel, \code{array($D$, $L$)} dénote le domaine réaliste des tableaux
dont les domaines et codomaines sont décrits par $D$ et dont la longueur
appartient à la disjonction $L$ de domaines réalistes d'entiers non-négatifs.
$D$ est une liste séparée par une virgule, entre \code{[} et \code{]}, de
{\strong descriptions} de paires de la forme \code{from $K$ to $V$}, où $K$ et
$V$ sont des disjonctions de domaines réalistes, respectivement pour les clés et
les valeurs. Quand le mot-clé \code{from} est manquant, nous introduisons le
domaine réaliste représentant un entier auto-incrémenté démarrant de 0 avec un
pas de 1.

\begin{example}[Tableaux homogènes et hétérogènes]

La syntaxe des descriptions de tableaux est illustrée avec les déclarations de
tableaux suivantes~:

\begin{pre}
a1: array([to boolean()], 7..42) \\
a2: array([from 0..5 or 10 to integer()], 7) \\
a3: array([from 0..10 to boolean(), from 20..30 to float()], 7) \\
a4: array([from 0..10 or 20..30 to boolean() or float()], 7)
\end{pre}

L'identifiant \code{a1} est déclaré comme un tableau homogène de booléens avec
une longueur comprise entre 7 et 42. L'identifiant \code{a2} est déclaré comme
un tableau homogène de longueur 7, dont les clés sont des entiers entre 0 et 5
ou simplement 10, et dont les valeurs sont des entiers. Les identifiants
\code{a3} et \code{a4} sont déclarés comme des tableaux hétérogènes. Les deux
tableaux peuvent contenir les paires $(\code{5}, \code{true})$ et $(\code{25},
\code{4.2})$, mais \code{a4} peut contenir la paire $(\code{5}, \code{4.2})$,
alors que \code{a3} ne peut pas la contenir.

\end{example}

En fait, nous introduisons une {\strong forme normale} pour supprimer les
disjonctions dans les descriptions des paires, en appliquant itérativement la
règle de réécriture suivante~:

\begin{center}
\begin{tabular}{c}
\code{from $F_1$ or $F_2$ to $T_1$ or $T_2$} \\
\hline
\code{from $F_1$ to $T_1$, from $F_1$ to $T_2$, from $F_2$ to $T_1$, from $F_2$ to $T_2$} \\
\end{tabular}
\end{center}

Une description de tableau est en forme normale quand elle ne peut plus être
réduite par cette règle.

\begin{example}[Description de tableau en forme normale]

La déclaration suivante de \code{a4} est en forme normale~:

\begin{pre}
a4: array([from  0..10 to boolean(), \\
           from  0..10 to float(), \\
           from 20..30 to boolean(), \\
           from 20..30 to float()], 7)
\end{pre}

\end{example}

Dans la figure~\ref{figure:language:short_contract}, l'attribut \code{\_map} est
spécifié comme un tableau d'objets \code{File}, d'une longueur entre 0 et 65535.

\subsection{Exécution et assignement du verdict de tests}
\label{subsection:language:verdict}

Nous nous appuyons sur un \inenglish{runtime assertion checker} (RAC) pour
calculer le verdict du test. Ce verdict est basé sur la vérification
d'assertions à l'exécution. Le RAC manipule trois informations~: un système sous
test, un contrat et des données. Dans la
figure~\ref{figure:language:short_contract}, le système sous test peut être la
méthode \code{store}, le contrat est le contrat associé à cette méthode et les
données sont soit fournies, soit générées automatiquement (nous verrons comment
dans les chapitres suivants).

Quand la vérification d'une assertion échoue, une erreur spécifique est
produite. Les erreurs du RAC (aussi appelées les \inenglish{Praspel failures}
ou erreurs Praspel) peuvent être de cinq sortes~:
%
\begin{inparaenum}[$(i)$]
%
\item \inenglish{precondition failure}, quand une précondition n'est pas
satisfaite lors de l'invocation de la méthode~;
%
\item \inenglish{postcondition failure}, quand une postcondition n'est pas
satisfaite après l'exécution de la méthode~;
%
\item \inenglish{throwable failure}, quand l'exécution de la méthode lève une
exception inattendue~;
%
\item \inenglish{invariant failure}, quand un invariant de classe est cassé~; et
%
\item \inenglish{internal precondition failure}, qui correspond à la propagation
d'une \inenglish{precondition failure} à un niveau supérieur.
%
\end{inparaenum}

Le test réussit si aucune erreur Praspel n'est détectée. Autrement, il échoue,
et l'erreur avec des informations supplémentaires est consignée.

Par exemple, dans la figure~\ref{figure:language:short_contract}, prenons la
méthode \code{store} et son contrat.
%
Avec le jeu (\code{'foo'}, \code{null}), nous aurons une \inenglish{precondition
failure}~: la contrainte \code{file: class('File')} n'est pas respectée car la
méthode \code{predicate(\$q)} du domaine réaliste \code{Class} avec \code{\$q =
'foo'} retourne \code{false}, et aucun autre domaine réaliste n'est spécifié
pour cette variable.
%
Avec le jeu de paramètres (\code{new File(…)}, \code{null}), avec un fichier
vide, nous activerons le comportement par défaut et nous n'observerons aucune
erreur sur les préconditions. Nous sommes maintenant dans le post-état. Si la
méthode \code{store} retourne un booléen et que la méthode \code{isAttached} de
l'objet \code{File} retourne \code{true}, aucune erreur non plus sur la
postcondition.  Si cette méthode retourne autre chose que \code{true} ou que la
méthode \code{store} retourne autre chose qu'un booléen, nous aurons une
\inenglish{postcondition failure}. Si une exception est levée, nous aurons une
\inenglish{throwable failure}.
%
Avec le même jeu de paramètres mais un fichier de grande taille ne pouvant être
enregistré, nous activerons le comportement \code{full}. Nous devrons avoir une
exception levée de type \code{AllocationException}, avec une méthode
\code{getFilesystem} qui retournera l'instance de notre système de fichier. Le
fichier ne devra pas non plus être attaché, \ie sa méthode \code{isAttached}
devra retourner \code{false}. Si une autre exception est levée ou que la
postcondition exceptionnelle n'est pas respectée, nous aurons une
\inenglish{throwable failure}. Si aucune exception n'est levée, nous aurons une
\inenglish{postcondition failure}.
%
Si pendant avant ou après l'exécution de la méthode \code{store}, un invariant
est cassé, nous aurons une \inenglish{invariant failure}. Par exemple, si
l'attribut \code{\_map} contient autre chose que des objets \code{File} ou que
sa taille dépasse 65535.
%
Enfin, si la méthode \code{store} fait appel à la méthode \code{getUsage} en ne
respectant pas sa précondition (ici en lui donnant un argument par exemple),
alors une \inenglish{precondition failure} sera émise depuis la méthode
\code{getUsage}, qui sera ensuite traduite en \inenglish{internal precondition
failure} depuis la méthode \code{store}.
