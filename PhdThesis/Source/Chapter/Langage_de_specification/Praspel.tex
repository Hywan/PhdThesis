\def\gsep{$\quad::=\quad$}
\def\mvert{$\;\;|\;\;$}
\newcommand{\token}[1]{\underline{\code{php-#1}}}
\newcommand{\grule}[1]{\textit{#1}}

\section{Praspel}
\label{section:language:praspel}

Praspel est un acronyme anglais signifiant \inenglish{PHP Realistic Annotation
and SPEcification Language}. C'est un langage et un framework de test à partir
de contrats en PHP (voir la
Section~\ref{subsection:language:contract-based_testing}). Ce langage repose sur
les domaines réalistes.

Praspel est un {\strong langage d'annotation} car il s'écrit dans les
commentaires du code source du programme. PHP comprend trois catégories de
commentaires~: en ligne (avec \code{//} ou \code{\#}), multi-lignes (entre
\code{/*} et \code{*/}) et en bloc (entre \code{/**} et \code{*/}). C'est dans
cette dernière catégorie que nous écrirons Praspel, catégorie qui est
culturellement dédiée à l'écriture des annotations, documentations API etc.

Praspel est un \inenglish{Behavioral Interface Specification Language} ({\strong
BISL}) basé sur les contrats. Un {\strong contrat} est un modèle du comportement
du code, décrit à travers des contraintes formelles, alors appelées {\strong
clauses}, comme les préconditions, les postconditions et les invariants. Ces
contraintes sont généralement localisées dans le code source autour des données.
Dans le cas de Praspel, les invariants sont localisés sur les attributs des
classes et les préconditions avec les postconditions sont localisées sur les
paramètres des méthodes. La sémantique d'un contrat est la suivante~:

\begin{itemize}

\item l'appelant de la méthode s'engage à satisfaire la précondition~;

\item seulement dans ce cas, la méthode appelée s'engage à satisfaire sa
postcondition~;

\item les invariants, quant à eux, doivent être satisfait avant et après
l'exécution de la méthode.

\end{itemize}

Le reste de la section décrit les parties de la grammaire de Praspel, en forme
normale.

\subsection{Clauses}
\label{subsection:language:clauses}

\begin{figure}
\centering
\begin{tabular}{rcl}
\grule{specification} & \gsep &
    \grule{attribute-clauses} \mvert \grule{method-clauses} \\

\grule{attribute-clauses} & \gsep &
    \grule{invariant-clause}$^?$ \\

\grule{method-clauses} & \gsep &
    $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \grule{rbet-clauses} \\

\grule{rbet-clauses} & \gsep &
    $($ \grule{requires-clause} \code{;} $)^?$ \\ & &
    $($ \\ & &
    $\quad\,\,($ \grule{behavior-clause}$^+$ \grule{default-clause}$^?$ $)^?$ \\ & &
    \mvert $($ \grule{ensures-clause} \code{;} $)^?$
    $($ \grule{throwable-clause} \code{;} $)^?$ \\ & &
    $)$ \\
\end{tabular}

\caption{\label{figure:language:grammar_part0} Grammaire de Praspel en forme
normale~: les entités syntaxiques de plus haut niveau.}

\end{figure}

\begin{figure}
\centering
\begin{tabular}{rcl}
\grule{invariant-clause} & \gsep &
    \ainvariant \grule{expression} \\

\grule{requires-clause} & \gsep &
    \arequires \grule{expression} \\

\grule{behavior-clause} & \gsep &
    \abehavior \token{identifier} \code{\{} \\ & &
    \quad $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \quad \grule{rbet-clauses} \\ & &
    \code{\}} \\

\grule{default-clause} & \gsep &
    \adefault \code{\{} \\ & &
    \quad $($ \grule{description-clause} \code{;} $)^?$ \\ & &
    \quad $($ \grule{ensures-clause} \code{;} $)^?$ \\ & &
    \quad $($ \grule{throwable-clause} \code{;} $)^?$ \\ & &
    \code{\}} \\

\grule{ensures-clause} & \gsep &
    \aensures \grule{expression} \\

\grule{throwable-clause} & \gsep &
    \athrowable \grule{exceptional-expression} \\

\grule{description-clause} & \gsep &
    \adescription \token{string} \\
\end{tabular}

\caption{\label{figure:language:grammar_part1} Grammaire de Praspel en forme
normale~: les entités syntaxiques des clauses.}

\end{figure}

Un contrat est composé de clauses, dont la syntaxe est décrite dans les
Figures~\ref{figure:language:grammar_part0},
\ref{figure:language:grammar_part1}, \ref{figure:language:grammar_part2} et
\ref{figure:language:grammar_part3}. Dans ces figures, le style \code{token}
représente un lexème de la grammaire de Praspel, \grule{rule} représente une
entité syntaxique (règle) de la grammaire, et \token{token} représente un lexème
de la grammaire de PHP (pour être le plus proche possible du langage manipulé
par le développeur). La notation $e^r_s$ signifie que le motif $e$ est répété
$r$ fois, et séparé par $s$. $r$ peut être $?$, $+$ ou $*$, respectivement pour
0 ou 1 fois, 1 ou plusieurs fois et 0 ou plusieurs fois. Si $s$ n'est pas vide,
alors $s$ doit être un lexème.

\begin{figure}
\begin{bigpre}
class \(C\) \{ \\
\\
    /** \\
     * @invariant \(I\); \\
     */ \\
    protected \$a; \\
\\
    /** \\
     * @requires \(R\); \\
     * @behavior \(\alpha\) \{ \\
     *     @description 'Apply the \(\alpha\) process.'; \\
     *     @requires \(R\sb{\alpha}\); \\
     *     @behavior \(\beta\) \{ \\
     *         @requires  \(R\sb{\alpha.\beta}\); \\
     *         @ensures   \(E\sb{\alpha.\beta}\); \\
     *         @throwable \(T\sb{\alpha.\beta}\); \\
     *     \} \\
     * \} \\
     * @behavior \(\gamma\) \{ \\
     *     @requires \(R\sb{\gamma}\); \\
     *     \(\dots\) \\
     * \} \\
     * @default \{ \\
     *     @description 'Apply the fallback process.'; \\
     *     @ensures   \(E\sb{\m{D}}\); \\
     *     @throwable \(T\sb{\m{D}}\); \\
     * \} \\
     */ \\
    public function f ( ) \{ \} \\
\}
\end{bigpre}

\caption{\label{figure:language:typical_contract} Un contrat Praspel typique
avec toutes les clauses.}

\end{figure}

Les entités syntaxiques \grule{attribute-clauses} et \grule{method-clauses} de
la Figure~\ref{figure:language:grammar_part0} définissent respectivement les
clauses annotant les attributs d'une classe et ses méthodes. Toutes ces clauses
introduisent des expressions Praspel, détaillées dans la
Section~\ref{subsection:language:expressions}. L'entité syntaxique
\grule{method-clauses} montre l'ordre des clauses en forme normale. La grammaire
actuelle de Praspel est bien plus libérale~: elle accepte des clauses dans
n'importe quel ordre mais pour faciliter le raisonnement, nous ne présenterons
et ne travaillerons que sur une forme normale.

La Figure~\ref{figure:language:typical_contract} montre un contrat sous sa forme
la plus typique~: une classe \code{C} avec un attribut \code{a} et une méthode
\code{f}. La clause \ainvariant est localisée juste avant l'attribut \code{a}.
Les invariants sont vérifiés avant et après l'exécution du système. Les autres
clauses sont des clauses de méthode. Elles sont localisées juste avant l'en-tête
des méthodes.

La précondition d'une méthode est exprimée à l'aide de la clause \arequires, la
postcondition à l'aide de la clause \aensures. La précondition exprime des
contraintes sur le {\strong pré-état} du système, alors que la postcondition
exprime des contraintes sur le {\strong post-état} du système. Afin de modifier
l'état du système, il doit être exécuté en appelant une méthode. La clause
\aensures représente une {\strong postcondition normale}, mais le système peut
aussi lever une exception et être alors placé dans un {\strong post-état
exceptionnel}. La clause \athrowable exprime des contraintes sur cet état
particulier~: elle exprime les conditions sous lesquelles des exceptions peuvent
être levées par la méthode et aussi le post-état du système associé (par exemple
une exception a été levée mais le système est suffisamment propre pour tenter
une nouvelle exécution). La syntaxe de $T$ ($T_{\alpha.\beta}$ et $T_\m{D}$ dans
la Figure~\ref{figure:language:typical_contract}) est définie par l'entité
syntaxique \grule{exceptional-expression} dans la
Figure~\ref{figure:language:grammar_part2}. $T$ peut être \code{$T_C$ with
$T_E$}, où $T_C$ est une liste de nom de classes asssociée à un identifiant, et
$T_E$ est une expression, appelée {\strong postcondition exceptionnelle}, dont
la syntaxe est détaillée dans la Section~\ref{subsection:language:expressions}.
Tous les identifiants définis dans $T_C$ peuvent apparaître dans $T_E$. La
sémantique est la suivante~: si l'exception levée est une instance d'une classe
représentant une exception listée dans $T_C$, alors elle est assignée à
l'identifiant associée et la postcondition exceptionnelle $T_E$ doit être
satisfaite.

Une méthode peut avoir différents {\strong comportements} relatifs à ses
arguments et l'état du système. Praspel propose la clause \abehavior pour
représenter un comportement, identifié par un nom, et peut potentiellement
contenir une description informelle, grâce à la clause \adescription~; ces deux
informations peuvent s'avérer très utiles pour offrir un retour à l'utilisateur.
Les clauses \arequires, \aensures, \athrowable et \abehavior elle-même peuvent
apparaître à l'intérieur d'une clause \abehavior. Cette structure décrit des
comportements {\strong imbriqués}, comme illustré dans la
Figure~\ref{figure:language:typical_contract} dans laquelle le comportement
$\beta$ est imbriqué dans le comportement $\alpha$. À côté de ça, nous pouvons
également décrire des comportements {\strong alternatifs} en juxtaposant des
clauses \abehavior. Ceci est toujours illustré dans la
Figure~\ref{figure:language:typical_contract} avec le comportement $\gamma$,
frère du comportement $\alpha$. Les comportements sont, dans la pratique,
{\strong mutuellement exclusifs}. Cependant, la syntaxe autorise l'écriture de
comportement non-déterministe.

La clause \adefault est strictement équivalente à une clause
\abehavior avec une clause \arequires implicite décrivant la conjonction de
toutes les négations des clauses \arequires des comportements frères précédents.
Par exemple, la clause \arequires de \adefault pourrait mathématiquement
s'écrire $\neg R_\alpha \land \neg R_\gamma$.

Afin d'«~activer~» un comportement donné, sa clause \arequires doit être
satisfaite. Après l'exécution, le système est dans le post-état. Nous faisons
face à deux situations. Si c'est un post-état normal, alors la clause \aensures
du dernier comportement activé doit être satisfaite. Si c'est un post-état
exceptionel, alors c'est la clause \athrowable qui doit être satisfaite, \ie les
deux $T_C$ et $T_E$ doivent être satisfaits, comme décrit précédemment.

\subsection{Expressions}
\label{subsection:language:expressions}

Les Figures~\ref{figure:language:grammar_part2} et
\ref{figure:language:grammar_part3} décrivent les expressions Praspel. Nous
avons principalement trois sortes d'expressions~: déclarations, prédicats et
contraintes, respectivement présentées dans les paragraphes suivants.

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
\grule{expression} & \gsep &
  (\grule{declaration}$^+_\code{and}$ $\code{and})^?$ \\ & &
  (\grule{constraint}$^+_\code{and}$ $\code{and})^?$  \\ & &
   \grule{predicate}$^?_\code{and}$ \\

\grule{exceptional-expression} & \gsep &
    $($ $($ \grule{exception-identifier} $)^+_\code{or}$
    \code{with} \grule{expression} $)^+_{\code{or}}$ \\

\grule{exception-identifier} & \gsep &
    \token{classname} \token{identifier} \\
\end{tabular}
\end{center}

\caption{\label{figure:language:grammar_part2} Grammaire de Praspel en forme
normale~: les entités syntaxiques d'expressions.}

\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{rcl}
\grule{declaration} & \gsep &
    \code{let}$^?$ \grule{extended-identifier} \code{:} \grule{disjunction} \\

\grule{constraint} & \gsep &
    \grule{qualification} \mvert \grule{contains} \\

\grule{qualification} & \gsep &
    \grule{identifier} \code{is} \token{identifier}$^+_\code{,}$ \\

\grule{contains} & \gsep &
    \grule{extended-identifier} \code{contains} \grule{constant}$^+_\code{or}$ \\

\grule{predicate} & \gsep &
    \code{\bslash pred(} \token{string} \code{)} \\

\grule{disjunction} & \gsep &
    $($
    \grule{constant} \mvert \grule{realdom} \mvert \grule{extended-identifier}
    $)^+_\code{or}$ \\

\grule{realdom} & \gsep &
    \token{identifier} \code{(} \grule{argument}$^?_\code{,}$ \code{)} \\

\grule{argument} & \gsep &
    \code{default} \mvert \grule{realdom} \mvert \grule{constant} \mvert
    \grule{array} \\ & &
    \mvert \grule{extended-identifier} \\

\grule{constant} & \gsep &
    \grule{scalar} \mvert \grule{array} \\

\grule{scalar} & \gsep &
    \code{null} \mvert \token{boolean} \mvert \grule{number} \mvert
    \token{string} \\

\grule{number} & \gsep &
    \token{binary} \mvert \token{octal} \mvert \token{hexa} \mvert
    \token{decimal} \\

\grule{array} & \gsep &
    \code{[} \grule{pair}$^?_\code{,}$ \code{]} \\

\grule{pair} & \gsep &
    \code{from}$^?$ \grule{disjunction} \code{to} \grule{disjunction} \\ & &
    \mvert \code{to}$^?$ \grule{disjunction} \\

\grule{extended-identifier} & \gsep &
    \grule{array-access} \\

\grule{array-access} & \gsep &
    \grule{identifier} $($ \code{[} \grule{scalar} \code{]} $)^?$ \\

\grule{identifier} & \gsep &
    \token{identifier} \\ & &
    \mvert \code{this} $($ \code{->} \token{identifier} $)^*$ \\ & &
    \mvert $($ \code{self} \mvert \code{static} \mvert \code{parent} $)$
    $($ \code{::} \token{identifier} $)^+$ \\ & &
    \mvert \code{\bslash old(} \grule{extended-identifier} \code{)} \\ & &
    \mvert \code{\bslash result} \\
\end{tabular}
\end{center}

\caption{\label{figure:language:grammar_part3} Grammaire de Praspel en forme normale~:
entités syntaxiques de construction des expressions.}

\end{figure}

\begin{figure}
\begin{bigpre}
/** \\
 * \arequires seed:   7..42 or 153..256 and \\
 *           factor: 1.0.. and \\
 *           \(\bslash\)pred('isfemtotime() or isarch(64)'); \\
 * \aensures  \(\bslash\)result: array([to float()], 1..5); \\
 */ \\
public function generate ( \$seed, \$factor ) \{ ... \}
\end{bigpre}

\caption{\label{figure:language:short_contract} Exemple d'un court contrat.}

\end{figure}

\paragraph{Déclarations.} Une déclaration assigne un ou plusieurs domaines
réalistes à une variable à travers l'opérateur \code{:}. Une variable est soit
un attribut de classe, spécifié dans une clause \ainvariant, soit un paramètre
de la méthode, spécifié dans les autres clauses. La valeur d'une variable peut
appartenir à plusieurs domaines réalistes si la variable est définie par une
{\strong disjonction} de domaines réalistes, représentée par le mot-clé
\code{or}.  La Figure~\ref{figure:language:short_contract} représente un court
contrat contenant seulement une précondition et une postcondition. Cette figure
présente la variable \code{seed}, dont le domaine réaliste est soit un
intervalle entre 7 et 42, soit un intervalle entre 153 et 256, et la variable
\code{factor} avec un seul domaine réaliste qui est un réel supérieur ou égal à
1.0 (représenté par un intervalle de réels avec une seule borne inférieure
1.0~—~le sucre syntaxique \code{1.2..3.4} est équivalent à \code{boundfloat(1.2,
3.4)}~—). Une disjonction de domaines réalistes peut contenir n'importe quelle
sorte de domaine réaliste~: ce afin de mimer l'aspect dynamique de PHP.

Si une variable est précédée par le mot-clé \code{let}, cela signifie que c'est
une variable {\strong locale}, qui appartient au modèle et non pas au système
(attribut de classe ou paramètre d'une méthode). C'est très utile pour
manipuler des représentations intermédiaires de données.

La clause \aensures a une particularité~: elle peut contenir la variable
spéciale \aresult qui représente la valeur {\strong retournée} par la méthode.
Les clauses \aensures et \athrowable peuvent également faire {\strong référence}
à la valeur d'une variable dans le pré-état grâce à la construction \aold{i}, où
$i$ est le nom d'une variable.

\paragraph{Prédicats.} Toutes les constructions présentent dans Praspel
supportent la validation et la vérification, \ie par les propriétés de
prédicabilité et de générabilité des domaines réalistes. Chaque concept
introduit dans le langage doit supporter ces deux aspects. Mais ils arrivent que
certaines choses ne puissent pas être exprimées avec les constructions
actuelles. C'est pourquoi nous avons la construction «~boîte-noire~» \apred{p},
où $p$ est du code PHP. Cette construction permet à l'utilisateur d'exprimer des
contraintes arbitraires en utilisant PHP lui-même au lieu de Praspel. Le code
$p$ doit être un prédicat en forme normal {\strong disjonctive} (DNF). La
construction \apred{p} ne supporte que la validation (prédicabilité) et non pas
la vérification (générabilité). Le prédicat \apred{\code{'isfemtotime() or
isarch(64)'}} dans la Figure~\ref{figure:language:short_contract} signifie que
si le système supporte le temps femto (une variante du temps micro) ou si
l'architecture est en 64~bits, alors cette partie de la précondition est
satisfaite.

Parce que la construction \apred{p} est une boîte-noire, elle introduit du rejet
lors de la génération de données car les contraintes $p$ ne sont pas
considérées. En effet, quand nous générons des données, nous les validons auprès
des prédicats. Si un prédicat est trop fort, il invalide la donnée, et nous en
générons de nouvelles. Une telle situation peut conduire à une boucle infinie.
Heureusement, il existe un nombre maximum d'essais (qui est paramétrable). Quand
ce nombre est atteint, le générateur abandonne et émet une erreur qui sera
journalisée.

Une tâche récurrente est d'observer et analyser ce que les utilisateurs écrivent
le plus dans cette construction, et l'extraire dans Praspel afin de supporter
les deux aspects~: validation et vérification. L'objectif est de faire évoluer
le langage en supportant plus de constructions usuelles nativement au lieu de
les avoir dans une boîte-noire, et ainsi, entre autre, réduire le rejet lors de
la génération de données. Ce processus est illustré dans la
Section~\ref{section:data:arrays}.

\paragraph{Contraintes.} Praspel a principalement deux sortes de contraintes~:
soit en utilisant la syntaxe des déclarations, soit en utilisant le mot-clé
\code{is}. Des exemples de contraintes sont présentées dans la
Section~\ref{section:data:arrays}.

\subsection{Description de tableaux}
\label{subsection:language:array}

La description de tableaux est une partie très important de Praspel, contrôlant
la génération de tableaux présentée dans la Section~\ref{section:data:arrays}.

Dans PHP, un tableau est toujours un {\strong tableau associatif} (ou une
\inenglish{map} ou un {\strong dictionnaire}), \ie une collection de paires
clé-valeur, où chaque clé apparaît au maximum une fois. Les clés peuvent être de
type nul, booléen, entier, réel ou chaîne de caractères. PHP accepte ces types
de clés mais les booléens sont transtypés en entier et les réels sont réduits à
leur partie entière. Les valeurs quant à elles peuvent être de n'importe quel
type. Un tableau peut être {\strong homogène} ou {\strong hétérogène}. Dans un
tableau homogène, toutes les clés ont le même type, ainsi que toutes les
valeurs. Dans un tableau hétérogène, les clés peuvent avoir des types distincts,
tout comme les valeurs.  Les clés peuvent être {\strong auto-incrémentées}, en
ajoutant 1 à la dernière clé entière, à partir de 0. La {\strong longueur} (ou
la {\strong taille}) d'un tableau est son nombre de paires. Un tableau n'a pas
de longueur prédéfinie, mais sa longueur (stockée en interne par le moteur PHP)
peut être connu grâce à la fonction PHP \code{count()}. Un tableau n'a également
pas de profondeur prédéfinie, \ie il peut contenir un nombre arbitraire de
sous-tableaux.

Dans Praspel, \code{array($D$, $L$)} dénote le domaine réaliste des tableaux
dont les domaines et codomaines sont décrits par $D$ et dont la longueur
appartient à la disjonction $L$ de domaines réalistes d'entiers non-négatifs.
$D$ est une liste séparée par une virgule, entre \code{[} et \code{]}, de
{\strong descriptions} de paires de la forme \code{from $K$ to $V$}, où $K$ et
$V$ sont des disjonctions de domaines réalistes, respectivement pour les clés et
les valeurs. Quand le mot-clé \code{from} est manquant, nous introduisons le
domaine réaliste représentant un entier auto-incrémenté démarrant de 0 avec un
pas de 1.

\begin{example}[Tableaux homogènes et hétérogènes]

La syntaxe des descriptions de tableaux est illustrée avec les déclarations de
tableaux suivantes~:

\begin{pre}
a1: array([to boolean()], 7..42) \\
a2: array([from 0..5 or 10 to integer()], 7) \\
a3: array([from 0..10 to boolean(), from 20..30 to float()], 7) \\
a4: array([from 0..10 or 20..30 to boolean() or float()], 7)
\end{pre}

L'identifiant \code{a1} est déclaré comme un tableau homogène de booléens avec
une longueur comprise entre 7 et 42. L'identifiant \code{a2} est déclaré comme
un tableau homogène de longueur 7, dont les clés sont des entiers entre 0 et 5
ou simplement 10, et dont les valeurs sont des entiers. Les identifiants
\code{a3} et \code{a4} sont déclarés comme des tableaux hétérogènes. Les deux
tableaux peuvent contenir les paires $(\code{5}, \code{true})$ et $(\code{25},
\code{4.2})$, mais \code{a4} peut contenir la paire $(\code{5}, \code{4.2})$,
alors que \code{a3} ne peut pas la contenir.

\end{example}

En fait, nous introduisons une {\strong forme normale} pour supprimer les
disjonctions dans les descriptions des paires, en appliquant itérativement la
règle de réécriture suivante~:

\begin{center}
\begin{tabular}{c}
\code{from $F_1$ or $F_2$ to $T_1$ or $T_2$} \\
\hline
\code{from $F_1$ to $T_1$, from $F_1$ to $T_2$, from $F_2$ to $T_1$, from $F_2$ to $T_2$} \\
\end{tabular}
\end{center}

Une description de tableau est en forme normale quand elle ne peut plus être
réduite par cette règle.

\begin{example}[Description de tableau en forme normale]

La déclaration suivante de \code{a4} est en forme normale~:

\begin{pre}
a4: array([from  0..10 to boolean(), \\
           from  0..10 to float(), \\
           from 20..30 to boolean(), \\
           from 20..30 to float()], 7)
\end{pre}

\end{example}

\subsection{Exécution et assignement du verdict de tests}
\label{subsection:language:verdict}

Le verdict du test est basé sur la vérification d'assertions à l'exécution
(\inenglish{runtime assertion checking}, abbrégé RAC) du contrat spécifié dans
le code source. Quand la vérification d'une assertion échoue, une erreur
spécifique est produite. Les erreurs de la RAC (aussi appelées les
\inenglish{Praspel failures} ou erreurs Praspel) peuvent être de cinq sortes~:
%
\begin{inparaenum}[$(i)$]
%
\item \inenglish{precondition failure}, quand une précondition n'est pas
satisfaite lors de l'invocation de la méthode~;
%
\item \inenglish{postcondition failure}, quand une postcondition n'est pas
satisfaite après l'exécution de la méthode~;
%
\item \inenglish{throwable failure}, quand l'exécution de la méthode lève une
exception inattendue~;
%
\item \inenglish{invariant failure}, quand un invariant de classe est cassé~; et
%
\item \inenglish{internal precondition failure}, qui correspond à la propagation
d'une \inenglish{precondition failure} à un niveau supérieur.
%
\end{inparaenum}

Le test réussit si aucune erreur Praspel n'est détectée. Autrement, il échoue,
et l'erreur avec des informations supplémentaires est consignée.
