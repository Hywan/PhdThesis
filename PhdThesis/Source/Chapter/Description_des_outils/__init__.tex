\chapter{Description des outils}
\label{chapter:tools}

\minitoc

Ce chapitre est consacré à la description des outils~: comment est implémenté
Praspel, comment il est maintenu, bla bla.

\section{Praspel}
\label{section:tools:praspel}

Cette partie est consacrée à présenter l'implémentation et l'outillage de
Praspel. Tout d'abord, la partie~\ref{subsection:tools:model} présente
l'architecture et le modèle objet de Praspel. Ensuite, la
partie~\ref{subsection:tools:interpretation} présente comment l'interpréter,
suivie de la partie~\ref{subsection:tools:compilation} qui présente comment le
compiler. Puis, la partie~\ref{subsection:tools:evaluation} présente comment
l'évaluer. Et enfin, comme Praspel est un langage de spécification destiné à PHP
construit de façon modulaire et extensible, pour faciliter son développement et
sa maintenance, nous avons choisi de nous appuyer sur le projet Hoa, présenté
dans la partie~\ref{subsection:tools:hoa}.

\subsection{Modèle objet}
\label{subsection:tools:model}

\begin{figure}

\drawfig{10.2cm}{!}{node distance=3cm}{
    \tikzstyle{rectangle}=[draw=black, thick, text centered, text width=2cm]
    \tikzstyle{arrow}=[->, >=latex, shorten >=1pt, thick]

    \node (model) [rectangle, minimum height=3cm] {
        Modèle objet

        \raisebox{0cm}[1.5cm]{
            \begin{tikzpicture}[node distance=4cm]
            \node [state, scale=.15] (foo1) {};
            \node [state, scale=.15, below left of=foo1] (foo2) {};
            \node [state, scale=.15, below right of=foo1] (foo3) {};
            \node [state, scale=.15, below left of=foo3] (foo4) {};
            \node [state, scale=.15, below right of=foo3] (foo5) {};
            \draw [thick] (foo1) -- (foo2) (foo1) -- (foo3) (foo3) -- (foo4) (foo3) -- (foo5);
            \end{tikzpicture}
        }
    };
    \node (language) [left of=model] {
        Langage
    };
    \node (php) [right of=model] {
        PHP
    };
    \node (verdict) [rectangle, below of=model, minimum height=1cm, node distance=4cm] {
        Verdict
    };
    \node (callable) [left of=verdict] {
        \inenglish{Callable}
    };

    \draw[arrow] (language.north)
                     -- node[auto] {\small interprétation}
                     ++(0,  1.68)
                     -| ([xshift=-5pt] model.north);
    \draw[arrow] ([xshift=+5pt] model.north)
                     --
                     ++(0,  0.5)
                     -| node[auto, yshift=-.9cm] {\small compilation} (php.north);
    \draw[arrow] (php.south)
                     -- node[auto] {\small exécution}
                     ++(0, -1.72)
                     -| ([xshift=+5pt] model.south);
    \draw[arrow] ([xshift=-5pt] model.south)
                     --
                     ++(0, -0.5)
                     -| node[auto, yshift=.8cm] {\small désassemblage} (language.south);
    \draw[arrow] (model.south)
                     --
                     node[auto, yshift=-.13cm] {évaluation} (verdict.north);
    \draw[arrow] (callable.east)
                     --
                     (verdict.west);
}

\caption{\label{figure:tools:praspel} Fonctionnement schématique de Praspel.}

\end{figure}

Praspel est un langage qui peut être aussi bien interprété que compilé, pour
être ensuite évalué. La figure~\ref{figure:tools:praspel} présente les
différents processus autour de Praspel. La pièce centrale de Praspel est le
modèle objet~: une variable est un objet, une clause est un objet, une
spécification (un contrat) est un objet etc. Tous ces objets sont imbriqués et
forme une structure qui s'apparente à un arbre. La racine de ce modèle est
représentée par un objet appelé
\code{Hoa\bslash{}Praspel\bslash{}Model\bslash{}Specification}.

Dans les parties suivantes, nous détaillons les différents processus autour de
ce modèle objet.

\subsection{Interprétation}
\label{subsection:tools:interpretation}

Le processus qui transforme le langage Praspel en modèle objet est appelé une
interprétation. À l'aide de la grammaire de Praspel exprimée avec le langage PP
et un compilateur, un AST représentant un contrat Praspel sera produit. Cet AST
sera par la suite visité afin de construire le modèle objet. Pour y arriver,
nous avons deux façons de faire. La première consiste à utiliser la méthode
\code{Hoa\bslash{}Praspel::interprete} qui est un raccourci~; ainsi~:
%
\begin{pre}
\$model = Hoa\bslash{}Praspel::interprete('@requires i: 7..42;');
\end{pre}
%
La seconde façon de faire détaille tous les outils, à savoir l'utilisation du
compilateur pour produire un AST, puis l'appel d'un visiteur pour interpréter
cet AST et produire le modèle objet~; ainsi~:
%
\begin{pre}
\$compiler    = Hoa\bslash{}Compiler\bslash{}Llk::load( \\
    new Hoa\bslash{}File\bslash{}Read('hoa://Library/Praspel/Grammar.pp') \\
); \\
\$ast         = \$compiler->parse('@requires i: 7..42;'); \\
\$interpreter = new Hoa\bslash{}Praspel\bslash{}Visitor\bslash{}Interpreter(); \\
\$model       = \$interpreter->visit(\$ast);
\end{pre}
%
Durant la production de l'AST, les erreurs syntaxiques seront détectées. Et
durant la production du modèle objet, les erreurs sémantiques seront détectées.

\subsection{Compilation}
\label{subsection:tools:compilation}

Le processus qui transforme le modèle en code PHP est appelé une compilation.
Cette transformation est appliquée par un visiteur sur le modèle objet. Quand
le code PHP produit est exécuté, il reconstruit le modèle objet depuis lequel il
a été généré. Cela permet de «~sauvegarder~» le modèle en évitant la phase
d'interprétation qui peut être coûteuse dans certaines situations. Pour y
arriver, nous devons faire~:
%
\begin{pre}
\$compiler = new Hoa\bslash{}Praspel\bslash{}Visitor\bslash{}Compiler(); \\
echo \$compiler->visit(\$model);
\end{pre}
%
Cet exemple produira le code PHP suivant~:
%
\begin{pre}
\$praspel = new \bslash{}Hoa\bslash{}Praspel\bslash{}Model\bslash{}Specification(); \\
 \\
\$requires = \$praspel->getClause('requires'); \\
\$requires['i']->in = realdom()->boundinteger(7, 42);
\end{pre}
%
qui permet de construire le modèle objet contenu dans \code{\$model},
c'est~à~dire que la valeur de la variable \code{\$model} est strictement égale à
la valeur de la variable \code{\$praspel}. Cet exemple nous permet également
d'avoir un aperçu de l'API du modèle objet~: elle se veut le plus simple et
compréhensible possible. Une spécification est instanciée. Sur cette
spécification, la clause \arequires est obtenue pour y déclarer une variable
\code{i} dont les valeurs sont décrites par (ou présentent dans, \code{->in}) la
disjonction de domaines réalistes, créée à l'aide de la fonction \code{realdom}.
Cette fonction se comporte comme un macro.

\subsection{Désassemblage}
\label{subsection:tools:disassembler}

Le processus qui transforme le modèle objet vers le langage Praspel est appelé
un désassemblage~: c'est l'opération inverse de l'interprétation. Il permet par
exemple d'indiquer des erreurs avec précisions sous la forme originale de
Praspel~; ainsi~:
%
\begin{pre}
\$disassembler = new Hoa\bslash{}Praspel\bslash{}Visitor\bslash{}Praspel(); \\
echo \$disassembler->visit(\$model);
\end{pre}
Cette exemple produira le résultat suivant~:
%
\begin{pre}
@requires i: boundinteger(7, 42);
\end{pre}
%
Notons que le sucre syntaxique \code{7..42} a disparu.

Ce dernier processus, complété des précédents, nous permet de passer d'une
représentation vers n'importe quelle autre représentation de Praspel~: soit
textuelle, soit objet, soit PHP.

\subsection{Évaluation avec un \inenglish{Runtime Assertion Checker}}
\label{subsection:tools:evaluation}

Ce sont les \inenglish{assertion checkers} qui sont responsables d'évaluer
Praspel. À partir d'une spécification, racine du modèle objet, et d'un
\inenglish{callable}, c'est~à~dire une méthode ou une fonction qui représente
notre système sous test, un \inenglish{assertion checker} est capable d'évaluer
la spécification sur le système sous test. Les données nécessaires à
l'évaluation lui sont soit fournies, soit générer par lui-même à partir de la
spécification.

Actuellement, nous nous appuyons sur un \inenglish{runtime assertion checker},
abrégé RAC, pour calculer le verdict du test. Ce verdict est basé sur la
vérification d'assertions à l'exécution. Quand la vérification d'une assertion
échoue, une erreur spécifique est produite. Les erreurs du RAC (aussi appelées
les \inenglish{Praspel failures} ou erreurs Praspel) peuvent être de cinq
sortes~:
%
\begin{enumerate}

\item \inenglish{precondition failure}, quand une précondition n'est pas
satisfaite lors de l'invocation de la méthode~;

\item \inenglish{postcondition failure}, quand une postcondition n'est pas
satisfaite après l'exécution de la méthode~;

\item \inenglish{throwable failure}, quand l'exécution de la méthode lève une
exception inattendue~;

\item \inenglish{invariant failure}, quand un invariant de classe est cassé~; et

\item \inenglish{internal precondition failure}, qui correspond à la propagation
d'une \inenglish{precondition failure} à un niveau supérieur.

\end{enumerate}
%
Le test réussit si aucune erreur Praspel n'est détectée. Autrement, il échoue,
et l'erreur avec des informations supplémentaires est consignée.

À présent, illustrons comment utiliser le RAC de Praspel où le système sous test
est une fonction \code{f}~:
%
\begin{pre}
function f ( \$i ) \{ \} \\
 \\
\$rac = new Hoa\bslash{}Praspel\bslash{}AssertionChecker\bslash{}Runtime( \\
    \$model, \\
    xcallable('f') \\
); \\
\$rac->setData(['i' => 13]); \\
\$verdict = \$rac->evaluate();
\end{pre}
%
Dans ce cas, la variable \code{\$verdict} contiendra \code{true} car la
précondition (\code{\arequires i: 7..42}) est bien respectée. Si nous voulons
que les données soient générées automatiquement, nous devrons appeler la méthode
\code{\$ac->au\-to\-ma\-ti\-cal\-ly\-Ge\-ne\-ra\-te\-Data(true)} en plus de
définir le générateur numérique par défaut des domaines réalistes afin de
pouvoir appeler les méthodes \code{sample} sur ces derniers~:
%
\begin{pre}
Hoa\bslash{}Realdom::setDefaultSampler(new Hoa\bslash{}Sampler\bslash{}Random()); \\
\$rac = new Hoa\bslash{}Praspel\bslash{}AssertionChecker\bslash{}Runtime( \\
    \$model, \\
    xcallable('f') \\
); \\
\$rac->automaticallyGenerateData(true); \\
\$verdict = \$rac->evaluate();
\end{pre}

\begin{example}[Vérifications des assertions]

Dans la figure~\ref{figure:language:short_contract}
page~\pageref{figure:language:short_contract}, le système sous test peut être la
méthode \code{store}, le contrat est le contrat associé à cette méthode et les
données sont soit fournies, soit générées automatiquement. Considérons par
exemple la méthode \code{store} et son contrat dans la
figure~\ref{figure:language:short_contract}.
%
Avec le jeu (\code{'foo'}, \code{null}), nous aurons une \inenglish{precondition
failure}~: la contrainte \code{file: class('File')} n'est pas respectée car la
méthode \code{predicate(\$q)} du domaine réaliste \code{Class} avec $\code{\$q}
= \code{'foo'}$ retourne \code{false}, et aucun autre domaine réaliste n'est
spécifié pour cette variable.
%
Avec le jeu de paramètres (\code{new File(…)}, \code{null}), avec un fichier
vide, nous activerons le comportement par défaut et nous n'observerons aucune
erreur sur les préconditions. Nous sommes maintenant dans le post-état. Si la
méthode \code{store} retourne un booléen et que la méthode \code{isAttached} de
l'objet \code{File} retourne \code{true}, aucune erreur non plus sur la
postcondition.  Si cette méthode retourne autre chose que \code{true} ou que la
méthode \code{store} retourne autre chose qu'un booléen, nous aurons une
\inenglish{postcondition failure}. Si une exception est levée, nous aurons une
\inenglish{throwable failure}.
%
Avec le même jeu de paramètres mais un fichier de grande taille ne pouvant être
enregistré, nous activerons le comportement \code{full}. Nous devrons avoir une
exception levée de type \code{AllocationException}, avec une méthode
\code{getFilesystem} qui retournera l'instance de notre système de fichier. Le
fichier ne devra pas non plus être attaché, \ie sa méthode \code{isAttached}
devra retourner \code{false}. Si une autre exception est levée ou que la
postcondition exceptionnelle n'est pas respectée, nous aurons une
\inenglish{throwable failure}. Si aucune exception n'est levée, nous aurons une
\inenglish{postcondition failure}.
%
Si avant ou après l'exécution de la méthode \code{store}, un invariant est
cassé, nous aurons une \inenglish{invariant failure}. Par exemple, si l'attribut
\code{\_map} contient autre chose que des objets \code{File} ou que sa taille
dépasse 65535.
%
Enfin, si la méthode \code{store} fait appel à la méthode \code{getUsage} en ne
respectant pas sa précondition (ici en lui donnant un argument par exemple),
alors une \inenglish{precondition failure} sera émise depuis la méthode
\code{getUsage}, qui sera ensuite traduite en \inenglish{internal precondition
failure} depuis la méthode \code{store}.

\end{example}

\subsection{Hoa, un ensemble de bibliothèques PHP}
\label{subsection:tools:hoa}

Hoa~\acite{Hoa} se définit comme «~un ensemble de bibliothèques PHP {\em
modulaires}, {\em extensibles} et {\em structurées}~». De plus, «~Hoa souhaite
être un pont entre le monde de la recherche et de l'industrie~». Ce projet
comporte des bibliothèques solides pour une multitude de domaines. Entre autre,
il offre une consistence entre les versions de PHP et est très respectueux des
standards. Hoa est également impliqué dans plusieurs consortiums ou groupes de
décisions concernant plusieurs standards de l'Informatique ou du Web. Par
conséquent, il est plus facile d'écrire, de maintenir et de s'assurer de la
qualité des programmes constituants Praspel.

De plus, le fait que Hoa souhaite être un pont entre le monde de la recherche et
de l'industrie nous offre l'opportunité de faire valider nos expérimentations
par sa communauté ou ses utilisateurs. Mais aussi, Hoa est développé sous la
licence libre \inenglish{New BSD License}\footnote{Voir
\url{http://hoa-project.net/En/About.html\#License}.}, soit une licence
\inenglish{open-source}. Cela implique que les outils que nous avons développé
durant cette thèse, comme Praspel, le compilateur etc., sont gratuits et libres.
Cette approche offre deux avantages majeurs. Tout d'abord, des contributeurs de
tout horizon peuvent nous aider à corriger ou améliorer nos outils. Ça a été le
cas à plusieurs reprises où des contributeurs ont corrigé des erreurs dans
Praspel ou ont amélioré considérablement le compilateur, notamment en y ajoutant
le support Unicode, en améliorant les performances de l'analyseur lexical (pour
l'analyse de très grandes données) etc. Ensuite, puisque les outils sont
gratuits, des entreprises peuvent l'utiliser et nous offrir des retours
pertinents, comme nous le verrons dans le
chapitre~\ref{chapter:experimentations} avec les expérimentations.

Nos contributions et outils prennent la forme de bibliothèques dans Hoa, à
savoir \code{Hoa\bslash{}Realdom} pour les domaines réalistes,
\code{Hoa\bslash{}Praspel} pour le langage Praspel, \code{Hoa\bslash{}Compiler}
pour le compilateur et \code{Hoa\bslash{}Regex} pour les expressions régulières.
D'autres contributions plus minimes ne sont pas détaillées ici, comme l'ajout de
fonctionnalités dans la bibliothèque \code{Hoa\bslash{}Math}.

\subsubsection{\code{Hoa\bslash{}Realdom}}

La bibliothèque \code{Hoa\bslash{}Realdom}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Realdom}.} représente la
bibliothèque standard des domaines réalistes. Ils sont implémentés comme
présenté dans la partie~\ref{section:language:realdoms}
page~\pageref{section:language:realdoms}, à savoir que chaque domaine réaliste
est représenté par une classe.  Actuellement, une liste de 28~domaines réalistes
est proposée~:
%
\begin{itemize}

\item \code{Array}, représentant des tableaux~;

\item \code{Bag}, un sac pouvant contenir plusieurs domaines réalistes de
natures différentes~;

\item \code{Boolean}, représentant les booléens~;

\item \code{Boundfloat}, représentant un intervalle de réels~;

\item \code{Boundinteger}, représentant un intervalle d'entiers~;

\item \code{Class}, représentant des instances de classes~;

\item \code{Color}, représentant des couleurs au format \code{\#{\em rrggbb}}~;

\item \code{Constarray}, représentant les tableaux de Praspel, c'est~à~dire une
description de tableau~;

\item \code{Constboolean}, représentant les booléens de Praspel~;

\item \code{Constfloat}, représentant les réels de Praspel~;

\item \code{Constinteger}, représentant les entiers de Praspel~;

\item \code{Constnull}, représentant la valeur nulle de Praspel~;

\item \code{Conststring}, représentant les chaînes de caractères de Praspel~;

\item \code{Date}, représentant une date formatée~;

\item \code{Empty}, représentant une donnée vide~;

\item \code{Even}, représentant les nombres pairs~;

\item \code{Float}, représentant les réels~;

\item \code{Grammar}, représentant les chaînes de caractères spécifiées par une
grammaire~;

\item \code{Integer}, représentant les entiers~;

\item \code{Natural}, représentant les naturels (entiers auto-incrémentés)~;

\item \code{Number}, représentant les nombres (entiers ou réels)~;

\item \code{Object}, représentant un objet donné~;

\item \code{Odd}, représentant les nombres impairs~;

\item \code{Regex}, représentant les chaînes de caractères spécifiées par une
expression régulière~;

\item \code{Smallfloat}, représentant des petits réels~;

\item \code{Smallinteger}, représentant des petits entiers~;

\item \code{String}, représentant des chaînes de caractères~;

\item \code{Timestamp}, représentant des valeurs dans le temps~;

\item \code{Undefined}, représentant des valeurs non-définies.

\end{itemize}

Pour obtenir toutes les informations sur un domaine réaliste, nous pouvons nous
aider de l'outil en ligne de commande \code{hoa realdom:reflection}.

\begin{example}[Informations sur le domaine réaliste \code{Boundinteger}]

Par exemple, pour obtenir des informations sur le domaine réaliste
\code{Boundinteger}, en ligne de commande, nous ferons~:
%
\begin{bigpre}
\$ hoa realdom:reflection boundinteger \\
Realdom boundinteger \{ \\
 \\
    Implementation Hoa\bslash{}Realdom\bslash{}Boundinteger; \\
 \\
    Parent Hoa\bslash{}Realdom\bslash{}Integer; \\
 \\
    Interfaces \{ \\
 \\
        ArrayAccess; \\
        Countable; \\
        IteratorAggregate; \\
        Traversable; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Enumerable; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Finite; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Interval; \\
        Hoa\bslash{}Realdom\bslash{}IRealdom\bslash{}Nonconvex; \\
        Hoa\bslash{}Realdom\bslash{}Number; \\
        Hoa\bslash{}Visitor\bslash{}Element; \\
    \} \\
 \\
    Parameters \{ \\
 \\
        [#0 optional] Constinteger lower = -9223372036854775808; \\
        [#1 optional] Constinteger upper = 9223372036854775807; \\
    \} \\
\}
\end{bigpre}
%
Nous trouvons comme informations le nom de la classe qui représente
l'implémentation du domaine réaliste, toutes les interfaces utilisées par cette
implémentation (ici plusieurs de PHP et des domaines réalistes, comme présenté
dans la partie~\ref{subsection:language:realdom:classification}
page~\pageref{subsection:language:realdom:classification}), ainsi que les
paramètres avec leurs positions, filtres et valeurs par défaut.

\end{example}

Cette bibliothèque peut être utilisée seule, sans Praspel.

\subsubsection{\code{Hoa\bslash{}Praspel}}

La bibliothèque \code{Hoa\bslash{}Praspel}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Praspel}.} est responsable
de tout le support de Praspel, de l'interprétation à l'évaluation en passant par
la compilation, la couverture des contrats etc. La bibliothèque est découpée de
la façon suivante~:
%
\begin{itemize}

\item \code{AssertionChecker}, permet l'évaluation du modèle objet~;

\item \code{Bin}, contient des scripts, dont un \inenglish{shell} permettant
d'analyser et évaluer du code Praspel à la volée~;

\item \code{Exception}, contient toutes les catégories d'exceptions de Praspel,
dont les \inenglish{Praspel failures}~;

\item \code{Iterator}, contient entre autre les générateurs de tests unitaires à
partir de plusieurs critères de couverture sur un contrat~;

\item \code{Model}, contient le modèle objet, à savoir la pièce central du
langage Praspel~;

\item \code{Preambler}, permet de créer un préambule de test pour n'importe quel
système sous test~;

\item \code{Visitor}, contient l'interpréteur, le compilateur et le
désassembleur.

\end{itemize}

À la racine de la bibliothèque, nous trouvons entre autre la grammaire au format
PP, une classe nommée \code{Hoa\bslash{}Praspel} qui rassemble les opérations
usuelles sur le langage et une classe représantant une trace d'évaluation d'un
contrat. Le lien entre Praspel et les domaines réalistes se fait au niveau du
modèle objet dans la classe
\code{Hoa\bslash{}Praspel\bslash{}Model\bslash{}Variable}.

\subsubsection{\code{Hoa\bslash{}Compiler} et \code{Hoa\bslash{}Regex}}

Le compilateur LL($\star$) que nous avons développé dans la
partie~\ref{section:data:strings} page~\pageref{section:data:strings} est
représenté par la bibliothèque
\code{Hoa\bslash{}Compiler\bslash{}Llk}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Compiler}.} (un autre
compilateur LL(1) existait préalablement). Cette bibliothèque comprend aussi le
support du langage PP ainsi que des algorithmes de générations à partir de
grammaires, soient~: aléatoire uniforme, exhaustif borné et par couverture. Ces
algorithmes sont présents dans la sous-bibliothèque
\code{Hoa\bslash{}Com\-pi\-ler\bslash{}Llk\bslash{}Sam\-pler}.  Seuls les deux
derniers fonctionnent comme des itérateurs.

\begin{example}[Génération exhaustive bornée avec Hoa]

Pour générer toutes les données au format JSON dont la taille maximum des
séquences de lexèmes ne dépasse pas 10, nous écrirons~:
%
\begin{pre}
\$sampler = new Hoa\bslash{}Compiler\bslash{}Llk\bslash{}Sampler\bslash{}BoundedExhaustive( \\
    Hoa\bslash{}Compiler\bslash{}Llk::load( \\
        new Hoa\bslash{}File\bslash{}Read('hoa://Library/Json/Grammar.pp') \\
    ), \\
    new Hoa\bslash{}Regex\bslash{}Visitor\bslash{}Isotropic( \\
        new Hoa\bslash{}Math\bslash{}Sampler\bslash{}Random() \\
    ), \\
    10 \\
); \\
 \\
foreach(\$sampler as \$data) \\
    // compute \$data
\end{pre}

L'ordre des arguments des générateurs est toujours le même. En premier, nous
devons fournir la grammaire, puis le générateur pour les lexèmes et enfin, si
besoin, la taille (fixe, minimum ou maximum selon le générateur) de la donnée à
générer. Le seul générateur de lexème proposé actuellement est isotropique,
comme présenté dans la partie~\ref{subsection:data:isotropic_generation}
page~\pageref{subsection:data:isotropic_generation}.

\end{example}

La grammaire des expressions régulières se trouve également dans la bibliothèque
\code{Hoa\bslash{}Regex}\footnote{Voir
\url{http://central.hoa-project.net/Resource/Library/Regex}.} dans
\code{hoa://Library/Regex/Grammar.pp}.

\section{atoum}
\label{section:tools:atoum}

atoum~\acite{atoum}, sans majuscule, est aujourd'hui l'un des
\inenglish{frameworks} de tests unitaires les plus utilisés dans l'industrie.
Gratuit et \inenglish{open-source}, il compte une communauté active et plusieurs
utilisateurs et partenaires industriels importants. atoum est également inclue
dans plusieurs IDE et outils majeurs, comme Netbeans\footnote{Voir
\url{https://netbeans.org/}.}, Eclipse\footnote{Voir
\url{http://eclipse.org/}.}, Vim\footnote{Voir \url{http://vim.org/}.},
Travis-CI\footnote{Voir \url{http://travis-ci.com/}.}, Jenkins\footnote{Voir
\url{http://jenkins-ci.org/}.}, Coveralls\footnote{Voir
\url{https://coveralls.io/}.} etc. L'outil se définit comme «~{\em simple}, {\em
moderne} et {\em intuitif}~».

Les suites de tests générées par Praspel doivent être exécutables de plusieurs
façons (en ligne, isolée ou autre), des rapports doivent être produits, les
outils doivent être intégrés à des IDE etc. Tout ceci représente un important
travail. atoum comporte déjà toutes ces fonctionnalités. Nous avons donc choisi
de créer une extension pour introduire Praspel dans atoum. De plus, atoum ne
possède aucun générateur de données, alors que Praspel en propose plusieurs.
Cela a donc été encore plus naturel de rapprocher les deux projets. Cette
extension, appelée \code{atoum/praspel-extension}, est incluse dans la
distribution standard d'atoum «~sous-stéroide~», c'est~à~dire avec des outils
qui ajoutent des fonctionnalités à atoum.

Dans un premier temps, nous allons montrer comment utiliser atoum avec
quelqu'uns de ces avantages, puis dans un second temps, nous montrerons les
fonctionnalités offertes par l'extension.

\subsection{Écrire et exécuter un test}

atoum fonctionne basiquement en deux étapes~: écrire et exécuter des tests. Un
test est une méthode et une suite de tests est une classe. Ainsi, nous allons
tester que le résultat retourné par une certaine méthode \code{say} d'une classe
\code{Project\bslash{}HelloWorld} retourne bien la chaîne de caractères
\code{Hello World!}~:
%
\begin{pre}
class HelloWorld extends \bslash{}atoum\bslash{}test \{ \\
 \\
    public function testSay() \{ \\
 \\
        \$helloWorld = new \bslash{}Project\bslash{}HelloWorld(); \\
        \$this->string(\$helloWorld->say()) \\
                  ->isEqualTo('Hello World!'); \\
    \} \\
\}
\end{pre}
%
Puis nous exécutons le test en ligne de commande (modulo une intégration dans un
IDE)~:
%
\begin{pre}
\$ atoum --file Path/To/Our/Test.php \\
… \\
> Total test duration: 0.00 second. \\
> Total test memory usage: 0.25 Mb. \\
> Code coverage value: 100.00\% \\
> Running duration: 0.08 second. \\
> Success (1 test, 1/1 method, 0 void method, \\
           0 skipped method, 2 assertions)!
\end{pre}
%
Le rapport simple nous informe que le test s'est exécuté en moins de
0.005~seconde, que la mémoire utilisée a été de 0.25~Mb, que la couverture de
code (avec le critère tous-les-arcs) a été de 100\%, que l'ensemble s'est
exécuté en 0.08~seconde et que l'exécution de la seule suite de tests, ne
contenant qu'un seul test représentant deux assertions, a été un succès. \\

Au delà de l'intégration avec plusieurs outils industiels ou la production de
rapports détaillés, nous pouvons citer trois points forts de cet outil.

\subsubsection{Moteurs d'exécution}

Tout d'abord, il permet nativement (comprendre sans \inenglish{plugin}
supplémentaire) l'exécution des tests en ligne, en isolation ou en parallèle.
Une exécution en ligne va exécuter tous les tests les uns après les autres de
manière séquentielle dans le même processus. Une exécution en isolation va
exécuter tous les tests les uns après les autres mais dans un processus
nouvellement crée à chaque fois afin d'isoler le test des exécutions
précédentes. Et enfin, une exécution en parallèle va exécuter tous les tests en
isolation mais de manière concurrente. Cela permet d'accélérer les exécutions ou
d'assurer une fiabilité dans les résultats des tests.

\subsubsection{Collection d'asserteurs}

Le second point fort est sa collection importante d'asserteurs. Bien plus que de
simples \code{assertTrue} ou \code{assertFalse} que nous retrouvons dans la
majorité des autres \inenglish{frameworks} de tests unitaires, atoum propose des
asserteurs personnalisés pour chaque type de données.

\begin{example}[Asserteurs spécifiques avec atoum]

Par exemple, une simple assertion \code{1 - 0.97 === 0.33} sera fausse dans tous
les langages malgré le fait que ce résultat nous paraisse naturel. C'est
pourquoi atoum propose l'asserteur \code{isNearlyEqualTo} sur le groupe
d'asserteurs \code{float}~:
%
\begin{pre}
\$this->float(1 - 0.97)->isNearlyEqualTo(0.33);
\end{pre}

De même, nous pouvons trouver l'asserteur \code{containsValues} sur le groupe
\code{array} qui va vérifier que certaines valeurs sont bien présentes dans un
tableau~:
%
\begin{pre}
\$this->array([1, 1, 2, 3, 5, 8])->containsValues([1, 3]);
\end{pre}

Il existe encore plusieurs autres groupes d'asserteurs, notamment \code{output}
qui permet de tester les sorties du programme. Notons que ce groupe hérite du
groupe \code{string}~: l'héritage entre groupes est une autre fonctionnalité
intéressante.

\end{example}

\subsubsection{\inenglish{Mock}}

Enfin, le dernier point fort d'atoum est son système de \inenglish{mock}
(bouchon). Pour obtenir le \inenglish{mock} de n'importe quel objet, il suffit
de l'instancier sur l'espace de nom \code{Mock}.

\begin{example}[Bouchonner avec atoum]

Si nous voulons obtenir le \inenglish{mock} de la classe
\code{Project\bslash{}HelloWorld}, nous instancierons simplement la classe
\code{Mock\bslash{}Project\bslash{}HelloWorld}, où nous pourrons ensuite
contrôler le résultat de certaines méthodes~:
%
\begin{pre}
class HelloWorld extends \bslash{}atoum\bslash{}test \{ \\
 \\
    public function testSay() \{ \\
 \\
        \$helloWorld = new \bslash{}Mock\bslash{}Project\bslash{}HelloWorld(); \\
        \$this->calling(\$helloWorld)->say = 'Hello!'; \\
        \$this->string(\$helloWorld->say()) \\
                  ->isEqualTo('Hello!'); \\
    \} \\
\}
\end{pre}
%
Nous avons créer un \inenglish{mock} puis nous avons spécifié que la méthode
\code{say} retournera toujours \code{Hello!}.

\end{example}

Nous pouvons également forcer une méthode à retourner une exception à partir de
son troisième appel par exemple. Nous pouvons également bouchonner des fonctions
et objets standards de PHP. En somme, les fonctionnalités sont avancées et sont
accessibles facilement.

\subsection{\code{atoum/praspel-extension}}

Cette extension\footnote{Voir
\url{http://central.hoa-project.net/Resource/Contributions/Atoum/PraspelExtension}.}
introduit Praspel dans atoum. Elle propose deux fonctionnalités~:
%
\begin{itemize}

\item la génération automatique de données de test, qui n'est pas présente dans
atoum~;

\item la compilation de suites de tests générées avec Praspel en suite de tests
écrites avec l'API d'atoum~; les tests seront donc exécutables avec atoum.

\end{itemize}

\subsubsection{Asserteurs de générations de données de tests}

Dans un premier temps, nous donnons accès aux domaines réalistes dans atoum à
travers l'asserteur \code{realdom} qui permet de créer des disjonctions de
domaines réalistes. La syntaxe utilisée dans PHP est la plus proche possible de
la syntaxe utilisée dans Praspel.

\begin{example}[Déclaration de domaines réalistes dans atoum]

Pour déclarer l'intervalle d'entiers $[7; 13] \union [42; 153]$, nous écrirons~:
%
\begin{pre}
\$data = \$this->realdom->boundinteger( 7,  13) \\
                  ->or->boundinteger(42, 153);
\end{pre}
%
L'équivalent en Praspel serait \code{boundinteger(7, 13) or boundinteger(42,
153)} ou plus simplement \code{7..13 or 42..153}.

\end{example}

Ensuite, nous pouvons utiliser au choix l'asserteur \code{sample} ou
\code{sampleMany} pour générer une ou plusieurs données.

\begin{example}[Génération d'entiers avec atoum]

Pour générer respectivement 1 entier ou 7 entiers représentés par l'intervalle
de l'exemple précédent, nous devons écrire~:
%
\begin{pre}
\$integer  = \$this->sample(\$data); \\
\$integers = \$this->sampleMany(\$data, 7);
\end{pre}

\end{example}

\begin{example}[Génération de données plus fines avec atoum]

Nous proposons encore deux exemples pour générer plusieurs dates ou chaînes de
caractères spécifiées par une expression régulière. Tout d'abord, nous allons
générer des dates au format \code{d/m H:i} (par exemple \code{28/03 12:34})
entre hier et lundi prochain, qui sont des repères temporels relatifs~:

%
\begin{pre}
\$data = \$this->realdom->date( \\
    'd/m H:i', \\
    \$this->realdom->boundinteger( \\
        \$this->realdom->timestamp('yesterday'), \\
        \$this->realdom->timestamp('next Monday') \\
    ) \\
); \\
 \\
foreach(\$this->sampleMany(\$data, 7) as \$date) \\
    // compute \$date
\end{pre}
%
En Praspel, la déclaration du domaine réaliste s'écrirait de la façon suivante~:
%
\begin{pre}
date( \\
    'd/m H:i', \\
    boundinteger( \\
        timestamp('yesterday'), \\
        timestamp('next Monday') \\
    ) \\
)
\end{pre}

Ensuite, nous allons générer des chaînes de caractères qui contiennent
le mots-clé \code{foo} suivi des mots-clés \code{bar} ou \code{baz}~:
%
\begin{pre}
\$data = \$this->realdom->regex('/.+foo.+ba(r|z).+/'); \\
 \\
foreach(\$this->sampleMany(\$data, 7) as \$string) \\
    // compute \$string
\end{pre}

\end{example}

\subsubsection{Générations de suites de test unitaires}

Dans la partie~\ref{section:test:criteria} page~\pageref{section:test:criteria},
nous avons défini des critères de couvertures sur les contrats. Les critères
sont satisfaits par un ensemble de chemins dans les contrats. Un chemin est
représenté par un test. Praspel est capable de générer des tests correspondant à
ces chemins. Ces tests que nous pourrions qualifiés d'abstraits (car non
exécutables) sont compilés vers des tests écrits avec l'API d'atoum (donc
exécutables). Cette compilation s'effectue en ligne de commande~: plusieurs
classes seront analysées pour en extraire des contrats Praspel, qui seront à
leurs tours interprétés pour pouvoir appliquer les algorithmes de générations de
tests unitaires. Puis, l'extension va compiler ces tests vers des tests écrits
au format atoum. Ces tests seront enregistrés dans les fichiers appropriés
que nous pourrons par la suite exécuter avec atoum.

Si nous reprenons notre classe \code{Project\bslash{}HelloWorld} avec sa méthode
\code{say}, nous aurons le contrat suivant~:
%
\begin{pre}
class HelloWorld \{ \\
 \\
    /** \\
     * \aensures \aresult: 'Hello World!'; \\
     */ \\
    public function say ( ) \{ \\
 \\
        return 'Hello World!'; \\
    \} \\
\}
\end{pre}
%
Nous allons ensuite générer automatiquement les tests associés en utilisant la
ligne de commande suivante~:
%
\begin{pre}
\$ praspel --class 'Project\bslash{}HelloWorld' --test-root .
\end{pre}
%
L'option \code{-\empty{}-class} précise la ou les classes à analyser. L'option
\code{-\empty{}-test-root} précise où se trouve la racine des tests, en
l'occurence à l'endroit où nous exécutons la ligne de commande. Un fichier par
classe sera généré. Le résultat du fichier que nous venons de générer est le
suivant~:
%
\begin{bigpre}
class HelloWorld extends \bslash{}Atoum\bslash{}PraspelExtension\bslash{}Test \{ \\
 \\
    // … \\
 \\
    public function test say n\(\sp{\circ}\)1 ( ) \{ \\
 \\
        \$this \\
            ->if(\$this->praspel->ensures['\bslash{}result']->in = \\
                realdom()->const('Hello World!')) \\
            ->then \\
                ->praspel->verdict('\bslash{}Project\bslash{}HelloWorld');  \\
 \\
        return; \\
    \} \\
\}
\end{bigpre}
%
Nous pouvons enfin exécuter ce test avec atoum grâce à la ligne de commande
suivante~:
%
\begin{pre}
\$ atoum --file Path/To/Our/Generated/Test.php \\
… \\
> Total test duration: 0.01 second. \\
> Total test memory usage: 0.50 Mb. \\
> Code coverage value: 100.00\% \\
> Running duration: 0.06 second. \\
> Success (1 test, 1/1 method, 0 void method, \\
           0 skipped method, 1 assertion)!
\end{pre}
%
Sans surprise, la suite de tests a été exécutée avec succès.

\section{Synthèse}
