\section{Génération de tests}
\label{section:sota:test_generation}

Il existe plusieurs approches pour générer des tests, présentant différents
niveaux d'automatisation (manuellle, semi-automatique ou automatique), et
différents niveaux de connaissance du programme qui est testé (complète,
partielle ou inconnue, respectivement \inenglish{white-box},
\inenglish{grey-box} ou \inenglish{black-box}). Et orthogonalement, il existe
plusieurs techniques pour générer des données de tests unitaires. Soit basées
sur la résolution de contraintes (comme JML-Testing-Tools, TestEra, Korat ou
UDITA), ou l'exécution symbolique de code (comme EXE, DART, KLEE ou CUTE).

\paragraph{JML-Testing-Tools} Des outils supplémentaires ont été ajoutés à JML,
notamment JML-Testing-Tools~\acite{BouquetDLU05} qui est un animateur
symbolique. C'est une extension de BZ-Testing-Tools~\acite{Ambert02}, un
ensemble d'outils d'animation et de génération automatique de programme
B~\acite{Abrial05}, Z~\acite{Spivey89} ou de spécifications
Statechart~\acite{Harel87}, alors étendu pour supporter le paradigme objet de
Java. L'outil se base sur une spécification JML ainsi que sur un programme Java
pour l'animer~: il va faire une analyse symbolique du programme, proposer des
données à l'utilisateur qu'il va choisir, et décider du pas d'exécution
(symbolique) suivant. À chaque pas, de nouvelles contraintes apparaissent et
disparaissent, permettant de maintenir un environnement d'exécution (toujours
symbolique). L'utilisateur peut revenir sur chaque point de choix qu'il a fait.
Si une clause d'une spécification est violée durant l'animation, un
contre-exemple pourra être produit. Enfin, à n'importe quel moment,
l'utilisateur est capable d'enregistrer l'état de l'exécution en tant que réel
programme Java qui pourra être exécuter pour produire une donnée de test
concrète. C'est une manière simple pour l'utilisateur d'explorer ses
spécifications et de produire des données de tests sur mesures.

\paragraph{TestEra} L'outil TestEra~\acite{MarinovK01} est un langage
d'annotation de code Java. Ses préconditions, postconditions et invariants
expriment des contraintes avec le langage Alloy~\acite{Jackson02}. Alloy est un
langage de spécification déclaratif pour exprimer des contraintes structurelles
complexes. Son objectif étant d'instancier des micro-modèles, à l'aide de son
propre analyseur Alcoa~\acite{JacksonSS00}. TestEra passe des invariants
accompagnés de préconditions à l'analyseur d'Alloy, qui va lui générer plusieurs
instances de modèles satisfaisants cette spécification. Ensuite, TestEra va
concrétiser ces instances une par une, afin de produire des données valides en
Java. Ces dernières sont utilisées en tant que données de tests, c'est~à~dire
qu'elles vont servir à exécuter le SUT. Ensuite, TestEra regarde les sorties
produites par le SUT ainsi que son post-état, qui sont abstraits pour se ramener
au formalisme d'Alloy afin d'y être confrontés à la postcondition et aux
invariants. Si cette dernière vérification échoue, un contre-exemple est
produit. Sinon, le processus itère à l'instance suivante.

\paragraph{Korat} L'outil Korat~\acite{BoyapatiKM02} est la suite de TestEra.
Son objectif est de générer des structures de données complexes
non-isomorphiques de taille finie. Korat demande à l'utilisateur d'écrire un
prédicat en Java (appelé \code{repOK}), qui va valider ou invalider les
structures générées. Il y a plusieurs avantages à cette démarche~: l'utilisateur
est familier avec le langage puisqu'il l'utilise pour développer, il y a
plusieurs outils et environnements de développement qui peuvent aider à la
rédaction ou l'analyse de ce prédicat, et enfin, le prédicat peut
potentiellement déjà exister dans le programme. Korat va ensuite générer des
structures à partir des entrées de ce prédicat. Pour cela, Korat va analyser le
prédicat et indexer quels sont les accès aux méthodes et attributs sur la
structure qui influencent la décision du prédicat. Korat va ensuite jouer sur
ces méthodes et attributs afin de générer plusieurs structures candidates.
Korat demande également à l'utilisateur d'écrire une méthode de
\inenglish{finitization} qui précise la taille et la nature des données portées
par la structure. L'idée est de préciser à Korat dans quelle mesure il peut
modifier la structure pour générer de nouvelles structures candidates. Cette
technique assure qu'il y a un ensemble fini de structures candidates qui vont
être sélectionnées. Le programme Java contient des contrats écrits en JML. Les
prédicats de Korat sont appelés depuis JML et la postcondition fournit l'oracle
du test. Les tests sont alors exécutés sur un programme Java enrichie.

Korat se démarque de TestEra en proposant ses propres algorithmes de génération
de données candidates à partir de prédicats Java. Cette approche demande un
effort supplémentaire à l'utilisateur, car en plus d'écrire des contrats en JML,
il doit écrire une méthode pour un prédicat et une autre pour une
\inenglish{finitization}. Notons que cet effort est partiellement compensé par
le fait que, d'une part, écrire des spécifications est une bonne pratique, et
que d'autre part, l'utilisateur connaît déjà le langage dans lequel écrire ces
méthodes et que les prédicats lui seront très propablement utiles dans son
programme.

\paragraph{UDITA} Le langage UDITA~\acite{GligoricGJKKM10} étend le langage Java
afin de lui permettre de générer un ensemble fini de structures de données
complexes. UDITA est la suite de Korat. Nous retrouvons la démarche de demander
à l'utilisateur d'écrire lui-même des méthodes de génération de données mais les
contrats ont totallement disparu. UDITA ajoute à Java deux extensions~: des
primitives de choix non-déterministes et une primitive pour restreindre ces
choix. Ces constructions sont familiaires aux utilisateurs de vérificateur de
modèle comme Java PathFinder~\acite{VisserHBPL03}, sur lequel il s'appuye. UDITA
est d'ailleurs intégré au framework Java PathFinder en tant qu'extension. Grâce
aux points de choix non-déterministes, l'utilisateur n'écrit qu'une seule
méthode de génération de données, et UDITA est capable d'en générer plusieurs.
L'outil propose aussi à l'utilisateur des générateurs basiques, comme un
générateur de booléens, d'entiers, de nouveaux objets ou d'objets déjà créés.
Ces deux derniers permettent à l'utilisateur de créer des structures de données
récursives ou liées. En plus d'une méthode de génération de données, UDITA
demande à l'utilisateur d'écrire un filtre, notion identique aux prédicats de
Korat, si ce n'est qu'UDITA ne va pas s'en servir pour la génération de données,
mais uniquement pour filtrer les données générées~: chaque donnée qui passe le
filtre sera mise de côté pour servir de données de test.

Contrairement à Korat, UDITA ne demande pas de méthode de
\inenglish{finitization}, mais s'appuye sur ces points de choix
non-déterministes pour explorer l'espace de la structure tout en restant
borné~\acite{Marinov03, SullivanYCKJ04}. L'efficacité de la méthode s'appuye
sur les choix retardés~\acite{NollS07}, c'est~à~dire sur des évaluations
non-déterministes tardives~\acite{FischerKS09}.

\paragraph{JSConTest} Le langage JSConTest~\acite{HeideggerT12} permet d'annoter
des programmes Javascript avec des contrats. Javascript est un langage a typage
non-déclaré.  C'est pourquoi JSConTest propose que le contrat ne contienne que
la signature de la fonction annotée, soit ses entrées et sa sortie,
respectivement une précondition et une postcondition. JSConTest ne permet pas
d'exprimer d'invariants ni de comportements. Le fait de préciser les types
permet à JSConTest de réduire l'effort d'inférence en se limitant à un minimum
de fonctions à analyser. Les résultats de l'inférence servent à guider la
génération aléatoire de données de test. Le langage permettant d'exprimer la
signature est enrichi de quelques constructions également pour guider la
génération aléatoire. Un RAC permet d'exécuter les tests et d'en calculer le
verdict.

JSConTest, contrairement à JML ou UDITA, demande très peu d'effort à
l'utilisateur. Les auteurs pensent qu'écrire la signature ne peut pas être
négatif pour le développeur, surtout dans un langage où les types ne sont pas
déclarés. Cependant, le niveau d'expressivité sur les préconditions et
postconditions restent très faible. En revanche, comme démontré dans le travail
sur les types graduels~\acite{SiekT07}, pour un langage a typage dynamique et
faible comme Javascript ou PHP, même un contrat très simple qui spécifie le
typage des données peut être très utile et offrir de bons résultats, notamment
dans la détection de régressions. \\

UDITA nous permet de faire la transition de la technique boîte-noire vers
boîte-blanche. C'est~à~dire que nous allons quitter la spécification pour nous
positionner sur le code source du programme. Cette technique demande peu ou pas
d'efforts à l'utilisateur. Des travaux ont été réalisés dans ce sens pour
générer des données de test avec des techniques statiques, dynamiques ou
hybrides.

\paragraph{EXE} \inenglish{EXecution generated Executions}, abbrégé
EXE~\acite{CadarGPDE06, CadarGPDE08}, est un outil d'exécution symbolique pour
programmes C.  Au lieu d'exécuter le programme avec des valeurs construites
manuellement ou aléatoirement, EXE va exécuter le programme, préalablement
instrumenté, de manière symbolique. Durant cette exécution symbolique, EXE va
analyser et indexer toutes les contraintes sur les entrées symboliques (comme
les paramètres des fonctions) et ainsi calculer tous les chemins possibles dans
le programme.  Si EXE rencontre une instruction contenant une valeur symbolique,
alors il va analyser son environnement et générer de nouvelles contraintes.
Quand des embranchements sont rencontrés (comme une condition par exemple), EXE
va dupliquer les exécutions et les contraindre à emprunter chaque chemin de
l'embranchement (pour une condition, ce sera un chemin à vrai et un à faux).
Quand EXE arrive à la fin d'un chemin ou qu'il trouve une erreur, alors il va
automatiquement générer des données de tests à partir des contraintes récoltées.
EXE est accompagné de STP~\acite{GaneshD07}, un solveur de constraintes maison
conçu à l'origine pour EXE. C'est grâce à ce solveur que les valeurs vont être
concrétisées et utilisées comme données de tests sur le programme
non-instrumenté. Les mêmes chemins seront empruntés et les mêmes erreurs seront
trouvées, mais avec des valeurs concrètes, donc exploitables par le développeur.

\paragraph{DART} \inenglish{Directed Automated Random Testing}, abbrégé
DART~\acite{GodefroidKS05}, est également un outil de génération de données de
test à partir de l'analyse du programme. DART opère en trois étapes. Il
commence par extraire les interfaces du programme pour connaître ses
entrées. Ensuite il va générer aléatoirement des données pour ses entrées, et
l'exécuter. Et enfin, il analyse le comportement du programme pendant son
exécution pour détecter quels sont les chemins ou zones qui n'ont pas été
atteints. Cette analyse va permettre de guider la génération des nouvelles
entrées pour la prochaine exécution.

DART et EXE ont une approche similaire pour l'analyse des chemins. À chaque
embranchement du programme, DART va extraire des contraintes symboliques. Pour
générer les données de tests suivantes, il prendra la négation des contraintes
une par une, générer de nouvelles valeurs et le processus continue. Toutefois,
DART ne sait gérer que les contraintes sur les entiers alors qu'EXE sait gérer
des contraintes sur les entiers, les tableaux, les vecteurs de bits, le
transtypage, les opérations arithmétiques etc.

\paragraph{KLEE} L'outil KLEE~\acite{CadarDE08} est la suite d'EXE. Ses auteurs
font le constat suivant~: malgré le fait que les travaux sur l'exécution
symbolique sont encourageants, les outils ne sont toujours pas capables de
passer à l'échelle. En effet, le nombre de chemins dans les programmes sont
exponentiels, et les techniques d'exécutions symboliques n'arrivent plus à
résoudre toutes les contraintes générées. De même, l'exécution symbolique ne
prenait pas en compte l'environnement du programme, comme l'OS, le réseau ou
l'utilisateur. Ce sont ces deux problèmes qu'adresse KLEE grâce à de la
réduction et simplifications de contraintes, des améliorations sur l'exploration
des chemins et des optimisations de la réprésentation de l'environnement.

KLEE utilise toujours STP comme solveur de contraintes. \\

Nous voyons qu'il existe de nombreuses techniques avancées pour la génération de
données de test à partir d'exécution symbolique (nous pouvons citer
CUTE~\acite{SenMA05}, Pex~\acite{HalleuxT08} ou ARTOO~\acite{CiupaLOM08} qui
sont aussi des travaux du même genre). Toutefois, si nous repensons aux contrats
et que nous prenons du recul, nous remarquons que l'exécution symbolique ne
permet pas de vérifier qu'un programme fait bien ce que nous souhaitons. Les
erreurs à l'exécution (comme des pointeurs nuls, des dépassements de tableaux,
de tampons etc.) seront détectées, mais rien ne nous assure que le programme est
correct par rapport à une spécification.

%%% Il faut mélanger les spéc/contrats avec ses techniques de génération de
%%% données.
%%%
