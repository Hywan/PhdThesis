\chapter{État de l'art}
\label{chapter:state}

\minitoc

Les travaux présentés dans cette thèse sont liés à des activités relatives à la
validation et à la vérification de programmes PHP à travers un nouveau langage
de spécification accompagné de ses outils. Ces activités s'articulent autour de
trois axes majeurs~: langage de spécification, génération de données et
génération automatique de tests.

Informellement, nous pouvons voir un test comme étant composé de trois parties~:

\begin{enumerate}

\item un Système Sous Test (\inenglish{System Under Test}, abbrégé SUT)~;

\item des données pour exécuter ce SUT~;

\item un oracle, capable de nous calculer le verdict du test~: est-ce l'état
du SUT après son exécution est celui attendu ou non~?

\end{enumerate}

Aujourd'hui, dans le monde industriel, la majorité des tests sont écrits
manuellement, par des ingénieurs de test. Un SUT leur est fourni, ils
l'exécutent avec des données et calculent eux-même le verdict du test. Dans le
cas des tests automatisés, l'exécution et le calcul du verdict est fait par la
machine. C'est le rôle qui incombe aux frameworks xUnit, comme
JUnit~\acite{JUnit} pour Java, atoum~\acite{atoum} ou PHPUnit~\acite{PHPUnit}
pour PHP, CUnit~\acite{CUnit} pour C etc. Ce que font les ingénieurs de test
peut se résumer à écrire une spécification informelle exécutable. En effet, ils
transforment le cahier des charges en tests afin de vérifier et valider le
programme.

Toutefois, cela reste informelle. Et surtout, c'est une tâche laborieuse qui
peut revenir cher \footnote{TODO, environ la moitié du prix d'un projet}. Et
pourquoi ne pas écrire une spécification formelle, et la rendre exécutable~?
C'est~à~dire d'utiliser un langage formelle pour décrire le fonctionnement du
programme, puis dériver, à partir de cette spécification, des tests qui soient
exécutables et qui vont vérifier ou valider plusieurs aspects de cette
spécification.

Nous nous intéressons à des programmes écrits en PHP~\acite{PHP} pour plusieurs
raisons. D'une part, PHP est un langage non-typé, hautement dynamique et
multi-paradigme, ce qui nous apporte des problématiques encore peu ou pas abordé
dans l'état de l'art actuel.  De plus, aucun travaux ne considère PHP pour la
génération de données ou la génération de tests. De même, aucun langage de
spécification dédié à PHP n'existait avant les travaux de cette thèse. Par
ailleurs, plus de 85\% du Web fonctionne avec PHP. Cela implique qu'il y a un
marché important avec d'immenses besoins~; que ce soit des sites de
commerces\footnote{Etsy, \url{https://etsy.com/}.}, de banques, d'assurances, de
réseaux sociaux\footnote{Facebook, \url{https://facebook.com/}}, de moteurs de
recherche\footnote{Yahoo, \url{https://yahoo.com/}},
d'encyclopédie\footnote{Wikipedia, \url{https://wikipedia.org/}},
gouvernementaux\footnote{France, Belgique, Suisse, USA, Canada etc.} et
d'autres.

Cette thèse s'intéresse à la conformité entre un programme et sa spécification,
à travers la création d'un nouveau langage de spécification simple, pradgmatique
pour le Web et unifiant plusieurs théories. Chaque théorie introduit se verra
enrichie pour la rendre compatible avec le Web.

\section{\inenglish{Behavioral Interface Specification Languages}}
\label{section:sota:bisl}

Le terme {\strong spécification} signifie généralement une description précise
d'un comportement d'un artéfact. La {\strong vérification} signifie prouver
qu'une implémentation (c'est~à~dire un programme) satisfait une spécification
particulière dans toutes les exécutions et configurations possibles.
Généralement, une telle preuve est accomplie à l'aide de raisonnements
statiques. Et quand un raisonnement statique n'est pas possible ou suffisant,
nous pouvons utiliser une vérification dynamique, appelée aussi
\inenglish{runtime assertion checking}, abbrégé RAC~\acite{Geller76}.

Un {\strong langage de spécification} formelle est une notation mathématiquement
précise pour décrire les comportements et propriétés d'un programme. Les
{\strong notations formelles} aident à rendre les spécifications non-ambiguës,
moins dépendantes des normes culturelles, et ainsi moins sujettes à une mauvaise
interprétation. Par ailleurs, de part le fait qu'une notation est formelle, elle
peut être exploitée par une machine pour y appliquer un traitement automatique.
Les spécifications formelles peuvent alors aider à {\strong automatiser le
test}, autant pour générer les données de test~\acite{BernotGM91, KorelA98,
SankarH94, Jalote92} que pour calculer le verdict du test~\acite{CheonL02}.
C'est dans ces deux directions que nous allons nous tourner.

Les spécifications peuvent documenter les {\strong interfaces} d'un programme.
Par interfaces, il faut comprendre les parties du programme permettant de
manipuler les données. Nous parlons alors de {\strong langages d'annotations}.
De tels langages peuvent jouer un rôle central dans la programmation. Par
exemple, ils facilitent la maintenance du code, qui n'est généralement pas
suffisament expressif pour faire comprendre au développeur ses tenants et ses
aboutissants. Par ailleurs, lors d'une phase de \inenglish{debugging}, les
annotations permettent de localiser plus facilement la faute. Les annotations
font parfois parties de la grammaire du langage, ou alors, le cas échéant, elles
sont écrites dans des {\strong commentaires}.

\subsection{Langages de contrats}
\label{subsection:sota:dbc}

Les spécifications sont souvent utilisées sous la forme de {\strong
contrats}~\acite{Liskov86, Meyer92}. Nous parlons de programmations par contrats
ou encore de \inenglish{Design by Contract} (abbrégé DbC). Le terme {\em
contrat} est une métaphore conceptuelle avec les conditions et les obligations
d'un contrat d'entreprise. Ce paradigme demande au développeur d'écrire une
spécification formelle qui étend la définition classique des types
abstraits~\acite{LiskovZ74} avec les contraintes formelles suivantes~: les
{\strong préconditions}, les {\strong postconditions} et les {\strong
invariants}. Ces contraintes formelles sont aussi appelées des {\strong
clauses}. Les contrats sont apparus dans le langage Eiffel~\acite{MeyerNM87},
qui alors se basait sur le paradigme de la programmation orienté objet. Dans un
tel contexte, les préconditions et postconditions portaient sur les méthodes
(aussi appelées procédures ou routines) et les invariants sur les classes (aussi
appelés modules). D'autres usages des contrats ont été faits hors du paradigme
de la programmation orienté objet, par exemple avec des fonctions d'ordre
supérieures~\acite{FindlerF02}. Le \inenglish{Design by Contract} définit les
critères de conformité suivants~:

\begin{itemize}

\item si les invariants et la précondition de la méthode sont satisfaits avant
son appel,

\item alors la méthode s'engage à satisfaire les invariants et sa postcondition
après son exécution.

\end{itemize}

Par extension, nous comprenons qu'il existe deux états pour le SUT~: avant
l'exécution d'une méthode, il se trouve dans un {\strong pré-état}, et après
l'exécution d'une méthode, il se trouve dans un {\strong post-état}. Pour les
langages supportant les exceptions, il existe un post-état normal et un
post-état exceptionnel. Par ailleurs, nous disons que le test est un {\strong
succès} si aucune clause n'est violée, sinon le test est un {\strong échec}.

Les langages décrivant une spécification formelle à travers des contrats pour
le comportement des programmes, mais qui sont utilisés comme annotations, sont
appelés des {\strong langages de contrats}. Il en existe
plusieurs~\acite{HatcliffLLMP12}.

\paragraph{JML} Le \inenglish{Java Modeling Language}~\acite{JML} est un langage
de contrats pour Java~\acite{Java}. À la différence de Eiffel qui utilise
\code{require} et \code{ensure}, JML utilise les mots-clés \code{requires} et
\code{ensures} pour introduire les préconditions et les postconditions. Dans
Eiffel, une postcondition exceptionnelle est introduite par le mot-clé
\code{rescue} alors que dans JML, nous avons \code{signals}. Les invariants sont
dans les deux cas introduits par le mot-clé \code{invariant}. JML propose
également des identifiants réservés, comme \aresult, présent uniquement dans une
postcondition normale, et qui fait référence au résultat de la méthode.  De
même, nous trouvons la construction \aold{i}, présente uniquement dans une
postcondition, qui fait référence à la valeur de la données $i$ dans le
pré-état. JML propose également des constructions logiques, comme la relation
d'implication ($\implies$), d'équivalence ($\Longleftrightarrow$) ou des
quantificateurs comme \code{$\bslash$forall} ($\forall$) et
\code{$\bslash$exists} ($\exists$).

La distribution officielle de JML fournit principalement deux outils.  Le
premier, le \inenglish{Runtime Assertion Checker}, sert de
\inenglish{monitoring} au code Java, et le second, JMLUnit, s'appuyant sur le
précédent, est dédié à Java. Le RAC de JML~\acite{Cheon02} est un outil
permettant de vérifier les contrats JML lors de l'exécution du programme. Les
contrats sont traduits en code Java~\acite{Raghavan2005}. La proximité entre ces
deux langages est la clé de la démarche. En effet, la syntaxe des contrats JML
est similaire à celle de Java, et les mots-clés JML spécifiques (pour par
exemple les clauses, les quantificateurs etc.) sont traduits par des structures
Java adéquates. Néanmoins, cette similitude a des limites~: certaines
constructions du langage, comme les quantifications sur les objets, ne sont pas
traduisibles et donc ne peuvent pas être vérifiées. Le code Java d'origine est
ainsi enrichi par la vérification des contrats JML. Le binaire résultant est
plus important, ce qui engendre des ralentissements à l'exécution. Si une
contrainte n'est pas vérifiée, une exception spécifique est déclenchée signalant
le type de clause qui n'a pas été vérifiée (invariant, précondition etc.) ainsi
que l'état visibile du système au moment de l'exécution.
L'utilisation du RAC confère un moyen direct et efficace de s'assurer que les
contrats JML ne sont pas violés durant une exécution avec les données de
l'exécution.

\paragraph{ACSL} Le \inenglish{ANSI/C Specification Language}~\acite{ACSL} est
un langage de contrats pour C~\acite{C}, inspiré principalement du langage de
spécification de l'outil Caduceus~\acite{FilliatreM07}, dédié à la vérification
déductive de propriétés de comportements de programmes C. Caduceus est lui-même
inspiré de JML. Les langages se ressemblent: les mot-clés \code{requires} et
\code{ensures} introduisent respectivement une précondition et une
postcondition. Les invariants sont introduits avec le mot-clé \code{invariant}.
Plusieurs comportements peuvent être exprimés pour une même méthode avec le
mot-clé \code{behavior}. ACSL propose d'autres clauses pour exprimer des
lemmes, des axiomes ou des fonctions logiques.

Contrairement à JML, ACSL n'utilise pas de C pour exprimer ces contraintes mais
un langage plus simple, qui s'inspire toutefois de C (pour les opérateurs
arithématiques, logiques, les tableaux etc.) afin de ne pas perturber
l'utilisateur. D'autres contraintes sont présentes car intrinsèques au langage,
comme la logique des pointeurs, et d'autres ne sont pas présentes, comme les
exceptions.

ACSL est basé sur le \inenglish{Framework for Modular Analyses of C}, abbrégé
Frama-C~\acite{FramaC}. Cet outil propose plusieurs analyses de code C. ACSL
utilise cet outil pour de la vérification statique. C'est la grande différence
avec JML, qui lui repose sur un RAC, donc une vérification à l'éxécution, ce que
ne fait pas ACSL. Des extensions à Frama-C peuvent être installées pour
permettre à des outils externes, comme des assistants de preuves interactifs ou
à des prouveurs automatiques de théorèmes, d'aider à la vérification de
certaines spécifications.

\paragraph{Spec\#} Le langage Spec\#~\acite{SpecSharp} permet de faire de la
programmation par contrat pour C\#~\acite{CSharp}. Ce langage est très similaire
à ACSL, avec toutefois moins de clauses. Les préconditions sont introduites avec
le mot-clé \code{requires}, les postconditions avec le mot-clé \code{ensures}.
De même, les invariants sont introduits avec le mot-clé \code{invariant}. En
plus des quantificateurs \code{forall}, \code{exists} et \code{exists unique},
Spec\# propose \code{sum}, \code{product}, \code{min} etc. Les contraintes sont
exprimées avec un langage proche de C\#, toujours pour ne pas perturber
l'utilisateur, mais toutes les constructions de C\# ne sont pas présentes,
seulement un sous-ensemble.  Par ailleurs, Spec\# enrichit le langage C\# en lui
ajoutant des constructions permettant de vérifier l'absence ou la possible
présence de valeurs nulles (avec \code{!} ou \code{?}).

Tout comme ACSL, la vérification des contrats se fait statiquement, et non pas
dynamiquement via un RAC. Et contrairement à JML où les contrats sont
transformés en Java, ici ils sont transformés en Boogie~\acite{BarnettCDJL05},
un langage intermédiaire pour encoder des conditions de vérifications pour les
langages impératifs et orientés objets. Boogie s'appuye sur des solveurs
externes, notamment Z3~\acite{DeMoura2008}, pour vérifier les contrats. \\

Chaque langage de programmation répandu a son propre langage de contrats. Se
distinguent deux grandes familles de vérifications de contrats~: statique (à
l'aide de prouveur maison ou externe) ou dynamique, à l'aide d'un RAC. \\

%La vérification dynamique souffre d'une limitation majeure. Elle fournit
%seulement une couverture limité~: les spécifications sont souvent vérifiées avec
%les données des exécutions courantes. Ainsi, la vérification dynamique résulte
%souvent à une détection incomplète et tardive (potentiellement en production) de
%défauts. Une façon de pallier à cette limitation est soit d'utiliser une
%approche hybride~\acite{Flanagan06}, soit de générer des données pertinentes
%pour tenter de couvrir tous les comportements de la spécification.

\section{Test à partir de contrats}
\label{section:sota:cbt}

L'un des intérêts et usages principaux des contrats est pour le test. En effet,
le {\strong test à partir de contrats} (\inenglish{Contract-Based Testing},
abbrégé CBT) a été introduit pour exploiter les langages
de contrats afin de tester des programmes~\acite{Aichernig03}~:

\begin{itemize}

\item les invariants et les préconditions sont utilisées pour générer des
données de tests~;

\item les postconditions fournissent un oracle (partiel) capable de calculer le
verdict du test à l'exécution.

\end{itemize}

Rappelons qu'un test est composé de trois parties~: un SUT, des données et un
oracle. La première partie est présente, et les deux dernières nous sont données
en exploitant le contrat. Nous sommes alors capable de générer des tests
automatiquement. Comme nous sommes au niveau du code, et plus précisément, sur
les méthodes des classes (dans un contexte orienté objet), les tests seront
{\strong unitaires}. La plupart des outils des CBT travaillent en
\inenglish{black-box}\footnote{TODO~: préciser ou enlever.}.

Mais un test ne montre pas l'absence d'erreur, uniquement la présence. Et un bon
test est un test qui échoue. Dans la génération de tests, deux critères rentrent
en jeu~: la pertinence des données de test, ainsi que la pertinence des tests
par rapport à la spécification. En effet, une spécification peut décrire
plusieurs comportements~; chaque comportement serait tester par un ou plusieurs
tests.

\subsection{Génération de données de test}

Un contrat précise le comportement d'un programme. Les programmes manipulent
deux catégories de données~: scalaires, comme les booléens, les entiers, les
réels, les chaînes de caractères, et non-scalaires, comme des tableaux ou des
objets. Nous allons présenter 

% dire rapidement ce que JML, ACSL etc. utilisent pour générer des données.
% montrer les limitations.
% montrer ce qu'il se fait **en dehors** des contrats pour générer des données
% dire que ce serait super d'avoir ça dans les contrats
% mais comment le spécifier dans les contrats~? est-ce qu'on seulement on peut~?

\subsection{Génération de tests}

\section{Synthèse}

Nous avons choisi de créer un nouveau langage de spécification plutôt que de
reprendre et améliorer un langage existant.
%Une des raisons est la complexité des autres langages par rapport au niveau des
%ingénieurs de tests. Nous voulions un langage simple, abordable et pragmatique.
La raison principale est qu'il n'existe pas de langage de spécification unifiant
plusieurs théories de l'état de l'art. Plusieurs langages ont permis à des
théories intéressantes d'émerger, mais malheureusement, ces théories sont
trop souvent éparpillées, et donc inutilisables par un ingénieur de test car la
chaîne de développement deviendrait trop complexe.


%
%  Langage de spéc' :
%  
%      V&V
%          verification: are we building the product right?
%          validation: are we building the right product?
%  
%      Model-based Testing
%          super mais trop dur à faire
%  
%      Design-by-Contract
%          Eiffel
%              on explique les pré-, postconditions, invariants.
%  
%      Contract-based Testing
%          du MBT dans le code finalement
%          plus simple
%          plus rapide
%          on est au niveau unitaire du coup (proche du code)
%          on est au niveau black-box du coup
%              sauf si on annote des tests (tests paramétrés, tests fonctionnels…)
%  
%      Ça nous paraît être le bon endroit pour écrire une spéc' (annotation du
%      code), simple pour les développeurs, ça rentre dans les méthodes de dév'
%      etc.
%  
%      JML
%      Spec#
%      ACSL
%  
%      Bilan**
%  
%  
%  Génération de données :
%  
%      Une spécification décrit le fonctionnement du programme. Avec le
%      design-by-contract, on décrit les données.
%  
%      Deux approches :
%          validation : on va valider les données fournies
%          vérification : on va générer puis valider ses données
%  
%      Comment fait-on en général ?
%          Solveur ou autre/aléatoire
%          PHP manipule beaucoup les types suivants :
%              Entiers
%              Tableaux
%              Chaînes/grammaires
%              Objets
%  
%      Bilan**
%  
%  
%  Génération automatique de tests :
%  
%      On fait du contract-based testing
%      On prend une spéc', on génère des séquences d'exécution (des tests), avec
%      les données précédemment générées
%  
%      Comment générer des tests à partir d'une spéc' ?
%      Que cherche-t-on à atteindre ?
%      => couvrir tous les comportements de la spéc', since elle représente/reflète
%      le comportement du programme
%  
%      Qui a fait ça avant ?
%  
%      Bilan**
%  
%  
%  Synthèse
%  
%  
%  
%  
%  
%  Les outils à étudier :
%      Apollo (Sosym)
%   x  JML
%      JSConTest
%   x  Eiffel
%      Madsen
%      Yagg
%      Geno
%      YouGen
%      @Flajolet
%      @Howden
%      @Hennessy "Analysing the effectiveness of rule-coverage as a reduction…"
%      Korat
%      TestEra (pré-Korat)
%      UDITA (post-Korat)
%      Java PathFinder
%      Alloy
%      SpecExplorer
%   x  Spec#
%   x  ACSL
%      AsmL
%      Cute
%      Kleen (?)
%      Exe
%      Symstra
%      Jartege
%      Euclide
%      InKA
%      FDCC
%      ARTOO
%      AutoTest
%      Pex
%      Quickcheck
%      JML-Testing-Tools
