\chapter{État de l'art}
\label{chapter:state}

\minitoc

Les travaux présentés dans cette thèse sont liés à des activités relatives à la
validation et à la vérification de programmes PHP à travers un nouveau langage
de spécification accompagné de ses outils. Ces activités s'articulent autour de
trois axes majeurs~: langage de spécification, génération de données et
génération automatique de tests.

Informellement, nous pouvons voir un test comme étant composé de trois parties~:

\begin{enumerate}

\item un Système Sous Test (\inenglish{System Under Test}, abbrégé SUT)~;

\item des données pour exécuter ce SUT~;

\item un oracle, capable de nous calculer le verdict du test~: est-ce l'état
du SUT après son exécution est celui attendu ou non~?

\end{enumerate}

Aujourd'hui, dans le monde industriel, la majorité des tests sont écrits
manuellement, par des ingénieurs de test. Un SUT leur est fourni, ils
l'exécutent avec des données et calculent eux-même le verdict du test. Dans le
cas des tests automatisés, l'exécution et le calcul du verdict est fait par la
machine. C'est le rôle qui incombe aux frameworks xUnit, comme
JUnit~\acite{JUnit} pour Java, atoum~\acite{atoum} ou PHPUnit~\acite{PHPUnit}
pour PHP, CUnit~\acite{CUnit} pour C etc. Ce que font les ingénieurs de test
peut se résumer à écrire une spécification informelle exécutable. En effet, ils
transforment le cahier des charges en tests afin de vérifier et valider le
programme. Toutefois, cela reste informel. Et surtout, c'est une tâche
laborieuse qui peut revenir cher \footnote{TODO, environ la moitié du prix d'un
projet}. Et pourquoi ne pas écrire une spécification formelle, et la rendre
exécutable~?  C'est~à~dire d'utiliser un langage formelle pour décrire le
fonctionnement du programme, puis dériver, à partir de cette spécification, des
tests qui soient exécutables et qui vont vérifier ou valider plusieurs aspects
de cette spécification.

Nous nous intéressons à des programmes écrits en PHP~\acite{PHP} pour plusieurs
raisons. Comparé à des langages plus traditionnels, comme C ou Java, les
langages de scripts accélère le processus de développement grâce à la
flexibilité qu'ils offrent avec le typage dynamique, faible et le mélange de
paradigmes. Cependant, cette flexibilité rend plus difficile la compréhension du
comportement de certains programmes, tout comme il est plus difficile de
s'assurer que le programme n'est pas affecté par une modification. Ce type de
langage nous apporte des problématiques encore peu ou pas abordées dans l'état
de l'art actuel. De plus, aucun travaux ne considère PHP pour la génération de
données ou la génération de tests. De même, aucun langage de spécification dédié
à PHP n'existait avant les travaux de cette thèse. Par ailleurs, plus de 85\% du
Web fonctionne avec PHP. Cela implique qu'il y a un marché important avec
d'immenses besoins~; que ce soit des sites de commerces\footnote{Etsy,
\url{https://etsy.com/}.}, de banques, d'assurances, de réseaux
sociaux\footnote{Facebook, \url{https://facebook.com/}.}, de moteurs de
recherche\footnote{Yahoo, \url{https://yahoo.com/}.},
d'encyclopédie\footnote{Wikipedia, \url{https://wikipedia.org/}.},
gouvernementaux\footnote{France, Belgique, Suisse, USA, Canada etc.} et
d'autres. Nous tenons à préciser que nous nous intéressons à du test pour PHP et
non pas du test pour le Web, à travers un client HTML. Nous considérons PHP
uniquement, tout en orientant nos travaux vers les problématiques du Web.

Cette thèse s'intéresse à la conformité entre un programme et sa spécification,
à travers la création d'un nouveau langage de spécification simple, pradgmatique
pour le Web et unifiant plusieurs théories. Chaque théorie introduit se verra
enrichie pour la rendre compatible avec le Web.

\section{\inenglish{Behavioral Interface Specification Languages}}
\label{section:sota:bisl}

Le terme {\strong spécification} signifie généralement une description précise
d'un comportement d'un artéfact. La {\strong vérification} signifie prouver
qu'une implémentation (c'est~à~dire un programme) satisfait une spécification
particulière dans toutes les exécutions et configurations possibles.
Généralement, une telle preuve est accomplie à l'aide de raisonnements
statiques. Et quand un raisonnement statique n'est pas possible ou suffisant,
nous pouvons utiliser une {\strong validation} dynamique, pour tester
l'implémentation. Une validation dynamique est aussi appelée \inenglish{Runtime
Assertion Checking}, abbrégé RAC~\acite{Geller76}.

Un {\strong langage de spécification} formelle est une notation mathématiquement
précise pour décrire les comportements et propriétés d'un programme. Les
{\strong notations formelles} aident à rendre les spécifications non-ambiguës,
moins dépendantes des normes culturelles, et ainsi moins sujettes à une mauvaise
interprétation. Les langages de spécifications sont conçus pour adresser des
problèmes généraux ou spécialisés. Les langages de spécifications généraux, tel
que Z~\acite{Spivey89} ou OCL~\acite{RichtersG98} ne sont pas conçus pour une
méthodologie particulière ou des outils de vérifications. Cependant, les
langages de spécifications sont très souvent spécialisés, en fonction du type de
langage qu'ils visent~: typage statique et fort, ou dynamique et faible, orienté
objet ou fonctionnel etc. Par ailleurs, de part le fait qu'une notation est
formelle, elle peut être exploitée par une machine pour y appliquer un
traitement automatique.  Les spécifications formelles peuvent alors aider à
{\strong automatiser le test}, autant pour générer les données de
test~\acite{BernotGM91, KorelA98, SankarH94, Jalote92} que pour calculer le
verdict du test~\acite{CheonL02}.  C'est dans ces deux directions que nous
allons nous tourner.

Les spécifications peuvent documenter les {\strong interfaces} d'un programme.
Par interfaces, il faut comprendre les parties du programme permettant de
manipuler les données. Nous parlons alors de {\strong langages d'annotations}.
De tels langages peuvent jouer un rôle central dans la programmation. Par
exemple, ils facilitent la maintenance du code, qui n'est généralement pas
suffisament expressif pour faire comprendre au développeur ses tenants et ses
aboutissants. Par ailleurs, lors d'une phase de \inenglish{debugging}, les
annotations permettent de localiser plus facilement la faute. Les annotations
font parfois parties de la grammaire du langage, ou alors, le cas échéant, elles
sont écrites dans des {\strong commentaires}.

\subsection{Langages de contrats}
\label{subsection:sota:dbc}

Les spécifications sont souvent utilisées sous la forme de {\strong
contrats}~\acite{Liskov86, Meyer92}. Nous parlons de programmations par contrats
ou encore de \inenglish{Design by Contract} (abbrégé DbC). Le terme {\em
contrat} est une métaphore conceptuelle avec les conditions et les obligations
d'un contrat d'entreprise. Ce paradigme demande au développeur d'écrire une
spécification formelle qui étend la définition classique des types
abstraits~\acite{LiskovZ74} avec les contraintes formelles suivantes~: des
{\strong préconditions}, des {\strong postconditions} et des {\strong
invariants}. Ces contraintes formelles sont aussi appelées des {\strong
clauses}. Il est admis de dire qu'une clause contient des {\strong assertions}.
Les contrats sont apparus dans le langage Eiffel~\acite{MeyerNM87}, qui alors se
basait sur le paradigme de la programmation orienté objet. Dans un tel contexte,
les préconditions et postconditions portaient sur les méthodes (aussi appelées
procédures ou routines) et les invariants sur les classes (aussi appelés
modules). D'autres usages des contrats ont été faits hors du paradigme de la
programmation orienté objet, par exemple avec des fonctions d'ordre
supérieures~\acite{FindlerF02}. Le \inenglish{Design by Contract} définit les
critères de conformité suivants~:

\begin{itemize}

\item si les invariants et la précondition de la méthode sont satisfaits avant
son appel,

\item alors la méthode s'engage à satisfaire les invariants et sa postcondition
après son exécution.

\end{itemize}

Par extension, nous comprenons qu'il existe deux états pour le SUT~: avant
l'exécution d'une méthode, il se trouve dans un {\strong pré-état}, et après
l'exécution d'une méthode, il se trouve dans un {\strong post-état}. Pour les
langages supportant les exceptions, il existe un post-état normal et un
post-état exceptionnel, dans le cas où une exception a été levée. Par ailleurs,
nous disons que le test est un {\strong succès} si aucune clause n'est violée,
sinon le test est un {\strong échec}.

Les langages décrivant une spécification formelle à travers des contrats pour
le comportement des programmes, mais qui sont utilisés comme annotations, sont
appelés des {\strong langages de contrats}. Il en existe
plusieurs~\acite{HatcliffLLMP12}.

\paragraph{JML} Le \inenglish{Java Modeling Language}~\acite{JML} est un langage
de contrats pour Java~\acite{Java}. À la différence de Eiffel qui utilise
\code{require} et \code{ensure}, JML utilise les mots-clés \code{requires} et
\code{ensures} pour introduire les préconditions et les postconditions. Dans
Eiffel, une postcondition exceptionnelle est introduite par le mot-clé
\code{rescue} alors que dans JML, nous avons \code{signals}. Les invariants sont
dans les deux cas introduits par le mot-clé \code{invariant}. JML propose
également des identifiants réservés, comme \aresult, présent uniquement dans une
postcondition normale, et qui fait référence au résultat de la méthode.  De
même, nous trouvons la construction \aold{i}, présente uniquement dans une
postcondition, qui fait référence à la valeur de la données $i$ dans le
pré-état. JML propose également des constructions logiques, comme la relation
d'implication ($\implies$), d'équivalence ($\Longleftrightarrow$) ou des
quantificateurs comme \code{$\bslash$forall} ($\forall$) et
\code{$\bslash$exists} ($\exists$).

La distribution officielle de JML fournit principalement deux outils.  Le
premier, le \inenglish{Runtime Assertion Checker}, sert de
\inenglish{monitoring} au programme Java, et le second, JMLUnit, s'appuyant sur
le précédent, est dédié à Java. Le RAC de JML~\acite{Cheon02} est un outil
permettant de vérifier les contrats JML lors de l'exécution du programme. Les
contrats sont traduits en code Java~\acite{Raghavan2005}. La proximité entre ces
deux langages est la clé de la démarche. En effet, la syntaxe des contrats JML
est similaire à celle de Java, et les mots-clés JML spécifiques (pour par
exemple les clauses, les quantificateurs etc.) sont traduits par des structures
Java adéquates. Néanmoins, cette similitude a des limites~: certaines
constructions du langage, comme les quantifications sur les objets, ne sont pas
traduisibles et donc ne peuvent pas être vérifiées.

Le programme Java d'origine est ainsi enrichi par la vérification des contrats
JML. Le binaire résultant est plus important, ce qui engendre des
ralentissements à l'exécution. Si une contrainte n'est pas vérifiée, une
exception spécifique est déclenchée signalant le type de clause qui n'a pas été
vérifiée (invariant, précondition etc.) ainsi que l'état visibile du système au
moment de l'exécution.  L'utilisation du RAC confère un moyen direct et efficace
de s'assurer que les contrats JML ne sont pas violés durant une exécution avec
les données de l'exécution.

\paragraph{ACSL} Le \inenglish{ANSI/C Specification Language}~\acite{ACSL} est
un langage de contrats pour C~\acite{C}, inspiré principalement du langage de
spécification de l'outil Caduceus~\acite{FilliatreM07}, dédié à la vérification
déductive de propriétés de comportements de programmes C. Caduceus est lui-même
inspiré de JML. Les langages se ressemblent: les mot-clés \code{requires} et
\code{ensures} introduisent respectivement une précondition et une
postcondition. Les invariants sont introduits avec le mot-clé \code{invariant}.
Plusieurs comportements peuvent être exprimés pour une même méthode avec le
mot-clé \code{behavior}. ACSL propose d'autres clauses pour exprimer des
lemmes, des axiomes ou des fonctions logiques.

Contrairement à JML, ACSL n'utilise pas de C pour exprimer ces contraintes mais
un langage plus simple, qui s'inspire toutefois de C (pour les opérateurs
arithématiques, logiques, les tableaux etc.) afin de ne pas perturber
l'utilisateur. D'autres contraintes sont présentes car intrinsèques au langage,
comme la logique des pointeurs, et d'autres ne sont pas présentes, comme les
exceptions.

ACSL est basé sur le \inenglish{Framework for Modular Analyses of C}, abbrégé
Frama-C~\acite{FramaC}. Cet outil propose plusieurs analyses de programmes C.
ACSL utilise cet outil pour de la vérification statique. C'est la grande
différence avec JML, qui lui repose sur un RAC, donc une vérification à
l'éxécution, ce que ne fait pas ACSL. Des extensions à Frama-C peuvent être
installées pour permettre à des outils externes, comme des assistants de preuves
interactifs ou à des prouveurs automatiques de théorèmes, d'aider à la
vérification de certaines spécifications.

\paragraph{Spec\#} Le langage Spec\#~\acite{SpecSharp} permet de faire de la
programmation par contrat pour C\#~\acite{CSharp}. Ce langage est très similaire
à ACSL, avec toutefois moins de clauses. Les préconditions sont introduites avec
le mot-clé \code{requires}, les postconditions avec le mot-clé \code{ensures}.
De même, les invariants sont introduits avec le mot-clé \code{invariant}. En
plus des quantificateurs \code{forall}, \code{exists} et \code{exists unique},
Spec\# propose \code{sum}, \code{product}, \code{min} etc. Les contraintes sont
exprimées avec un langage proche de C\#, toujours pour ne pas perturber
l'utilisateur, mais toutes les constructions de C\# ne sont pas présentes,
seulement un sous-ensemble.  Par ailleurs, Spec\# enrichit le langage C\# en lui
ajoutant des constructions permettant de vérifier l'absence ou la possible
présence de valeurs nulles (avec \code{!} ou \code{?}).

Tout comme ACSL, la vérification des contrats se fait statiquement, et non pas
dynamiquement via un RAC. Et contrairement à JML où les contrats sont
transformés en Java, ici ils sont transformés en Boogie~\acite{BarnettCDJL05},
un langage intermédiaire pour encoder des conditions de vérifications pour les
langages impératifs et orientés objets. Boogie s'appuye sur des solveurs
externes, notamment Z3~\acite{DeMoura2008}, pour vérifier les contrats.

\paragraph{JSConTest} Le langage JSConTest~\acite{HeideggerT12} permet d'annoter
des programmes Javascript avec des contrats. Javascript est un langage a typage
non-déclaré.  C'est pourquoi JSConTest propose que le contrat ne contienne que
la signature de la fonction annotée, soit ses entrées et sa sortie,
respectivement une précondition et une postcondition. JSConTest ne permet pas
d'exprimer d'invariants ni de comportements. Le fait de préciser les types
permet à JSConTest de réduire l'effort d'inférence en se limitant à un minimum
de fonctions à analyser. Les résultats de l'inférence servent à guider la
génération aléatoire de données de test. Le langage permettant d'exprimer la
signature est enrichi de quelques constructions également pour guider la
génération aléatoire. Un RAC permet d'exécuter les tests et d'en calculer le
verdict.

JSConTest, contrairement à JML ou UDITA, demande très peu d'effort à
l'utilisateur. Les auteurs pensent qu'écrire la signature ne peut pas être
négatif pour le développeur, surtout dans un langage où les types ne sont pas
déclarés. Cependant, le niveau d'expressivité sur les préconditions et
postconditions restent très faible. En revanche, comme démontré dans le travail
sur les types graduels~\acite{SiekT07}, pour un langage a typage dynamique et
faible comme Javascript ou PHP, même un contrat très simple qui spécifie le
typage des données peut être très utile et offrir de bons résultats, notamment
dans la détection de régressions. \\

Se distinguent deux grandes familles de vérifications de contrats~: statique, à
l'aide de prouveurs maisons et externes, ou dynamique, à l'aide d'un RAC.

Presque chaque langage de programmation répandu a son propre langage de
contrats. Cette approche est en général bien acceptée par les développeurs car
elle est proche du code source du programme. Toutefois, selon la complexité du
langage de spécification, elle sera plus ou moins utilisée. Cette complexité
ressentie peut être compensée par d'autres services que peuvent offrir les
contrats.

\subsection{Test à partir de contrats}
\label{subsection:sota:cbt}

Il existe plusieurs approches pour générer des tests, présentant différents
niveaux d'automatisation (manuellle, semi-automatique ou automatique), et
différents niveaux de connaissance du programme qui est testé (complète,
partielle ou inconnue, respectivement \inenglish{white-box},
\inenglish{grey-box} ou \inenglish{black-box}).\footnote{TODO~: expliquer le
black-box and co.}

Jusqu'à maintenant, nous avons vu comment les contrats sont utilisés pour
{\strong filtrer} les données manipuler par un programme ou pour vérifier que le
programme ne produira pas d'erreur. Cependant, l'un des intérêts et usages
principaux des contrats est pour le {\strong test}. En effet, le {\strong test à
partir de contrats} (\inenglish{Contract-Based Testing}, abbrégé CBT) a été
introduit pour exploiter les langages de contrats afin de tester des
programmes~\acite{Aichernig03}~:

\begin{itemize}

\item les invariants et les préconditions sont utilisées pour {\strong générer
des données} de test~;

\item les postconditions {\strong fournissent un oracle} capable de calculer le
verdict du test à l'exécution.

\end{itemize}

Rappelons qu'un test est composé de trois parties~: un SUT, des données et un
oracle. La première partie est présente du fait de la proximité entre les
contrats et le programme, et les deux dernières nous sont données en exploitant
le contrat. À partir d'une spécification formelle, sous la forme d'un contrat,
nous sommes capable de générer des tests automatiquement. Comme nous sommes au
niveau du code source du programme, et plus précisément, sur les méthodes des
classes (dans un contexte orienté objet), les tests seront {\strong unitaires}.
La plupart des outils de CBT travaillent en
\inenglish{black-box}\footnote{TODO~: préciser ou enlever.}. \\

«~Un test montre la présence, jamais l'absence d'une erreur~» (Edsger
W.~Dijkstra dans~\acitep{Buxton70}). Et un bon test est un test qui échoue.

% Mais quelle métrique avons-nous pour qualifier un test~? CODE COVERAGE~!
% Est-ce que c'est toujours possible~? Ça dépend si on est en black-box,
% grey-box ou white-box.

La vérification dynamique souffre d'une limitation majeure. Elle fournit des
résultats limités~: les spécifications sont souvent vérifiées avec les données
des exécutions courantes et rarement de manière exhaustive. Ainsi, la
vérification dynamique résulte souvent à une détection incomplète et tardive
(potentiellement en production) de défauts. Une façon de pallier à cette
limitation est soit d'utiliser une approche hybride~\acite{Flanagan06}, soit de
générer des données de tests pertinentes pour tenter de couvrir tous les
comportements de la spécification.

\section{Génération de données de test}

Il existe plusieurs techniques pour générer des données de tests unitaires. Soit
basées sur la résolution de contraintes (comme TestEra, Korat ou UDITA), ou
l'exécution symbolique de code (comme Symstra, EXE, DART, KLEE ou CUTE).

\paragraph{TestEra} L'outil TestEra~\acite{MarinovK01} est un langage
d'annotation de code Java. Ses préconditions, postconditions et invariants
expriment des contraintes avec le langage Alloy~\acite{Jackson02}. Alloy est un
langage de spécification déclaratif pour exprimer des contraintes structurelles
complexes. Son objectif étant d'instancier des micro-modèles, à l'aide de son
propre analyseur Alcoa~\acite{JacksonSS00}. TestEra passe des invariants
accompagnés de préconditions à l'analyseur d'Alloy, qui va lui générer plusieurs
instances de modèles satisfaisants cette spécification. Ensuite, TestEra va
concrétiser ces instances une par une, afin de produire des données valides en
Java. Ces dernières sont utilisées en tant que données de tests, c'est~à~dire
qu'elles vont servir à exécuter le SUT. Ensuite, TestEra regarde les sorties
produites par le SUT ainsi que son post-état, qui sont abstraits pour se ramener
au formalisme d'Alloy afin d'y être confrontés à la postcondition et aux
invariants. Si cette dernière vérification échoue, un contre-exemple est
produit. Sinon, le processus itère à l'instance suivante.

\paragraph{Korat} L'outil Korat~\acite{BoyapatiKM02} est la suite de TestEra.
Son objectif est de générer des structures de données complexes
non-isomorphiques de taille finie. Korat demande à l'utilisateur d'écrire un
prédicat en Java (appelé \code{repOK}), qui va valider ou invalider les
structures générées. Il y a plusieurs avantages à cette démarche~: l'utilisateur
est familier avec le langage puisqu'il l'utilise pour développer, il y a
plusieurs outils et environnements de développement qui peuvent aider à la
rédaction ou l'analyse de ce prédicat, et enfin, le prédicat peut
potentiellement déjà exister dans le programme. Korat va ensuite générer des
structures à partir des entrées de ce prédicat. Pour cela, Korat va analyser le
prédicat et indexer quels sont les accès aux méthodes et attributs sur la
structure qui influencent la décision du prédicat. Korat va ensuite jouer sur
ces méthodes et attributs afin de générer plusieurs structures candidates.
Korat demande également à l'utilisateur décrire une méthode de
\inenglish{finitization} qui précise la taille et la nature des données portées
par la structure. L'idée est de préciser à Korat dans quelle mesure il peut
modifier la structure pour générer de nouvelles structures candidates. Cette
technique assure qu'il y a un ensemble fini de structures candidates qui vont
être sélectionnées. Le programme Java contient des contrats écrits en JML. Les
prédicats de Korat sont appelés depuis JML et la postcondition fournit l'oracle
du test. Les tests sont alors exécutés sur un programme Java enrichie.

Korat se démarque de TestEra en proposant ses propres algorithmes de génération
de données candidates à partir de prédicats Java. Cette approche demande un
effort supplémentaire à l'utilisateur, car en plus d'écrire des contrats en JML,
il doit écrire une méthode pour un prédicat et une autre pour une
\inenglish{finitization}. Notons que cet effort est partiellement compensé par
le fait que, d'une part, écrire des spécifications est une bonne pratique, et
que d'autre part, l'utilisateur connaît déjà le langage dans lequel écrire ces
méthodes et que les prédicats lui seront très propablement utiles dans son
programme.

\paragraph{UDITA} Le langage UDITA~\acite{GligoricGJKKM10} étend le langage Java
afin de lui permettre de générer un ensemble fini de structures de données
complexes. UDITA est la suite de Korat. Nous retrouvons la démarche de demander
à l'utilisateur décrire lui-même des méthodes de génération de données mais les
contrats ont totallement disparu. UDITA ajoute à Java deux extensions~: des
primitives de choix non-déterministes et une primitive pour restreindre ces
choix. Ces constructions sont familiaires aux utilisateurs de vérificateur de
modèle comme Java PathFinder~\acite{VisserHBPL03}, sur lequel il s'appuye. UDITA
est d'ailleurs intégré au framework Java PathFinder en tant qu'extension. Grâce
aux points de choix non-déterministes, l'utilisateur n'écrit qu'une seule
méthode de génération de données, et UDITA est capable d'en générer plusieurs.
L'outil propose aussi à l'utilisateur des générateurs basiques, comme un
générateur de booléens, d'entiers, de nouveaux objets ou d'objets déjà créés.
Ces deux derniers permettent à l'utilisateur de créer des structures de données
récursives ou liées. En plus d'une méthode de génération de données, UDITA
demande à l'utilisateur d'écrire un filtre, notion identique aux prédicats de
Korat, si ce n'est qu'UDITA ne va pas s'en servir pour la génération de données,
mais uniquement pour filtrer les données générées~: chaque donnée qui passe le
filtre sera mise de côté pour servir de données de test.

Contrairement à Korat, UDITA ne demande pas de méthode de
\inenglish{finitization}, mais s'appuye sur ces points de choix
non-déterministes pour explorer l'espace de la structure tout en restant
borné~\acite{Marinov03, SullivanYCKJ04}. L'efficacité de la méthode s'appuye
sur les choix retardés~\acite{NollS07}, c'est~à~dire sur des évaluations
non-déterministes tardives~\acite{FischerKS09}. \\

%%% Dire aussi qu'avec TestEra et Korat, on a encore une notion de contrats.
%%% Avec UDITA, la pré et la post se retrouvent un peu dans les 2 méthodes
%%% Bref, on demande à l'utilisateur de fournir quelque chose
%%%
%%% Avec ce qui va suivre, on regarde le code pour générer les données.
%%% Il y a des techniques avancées, super~!
%%%
%%% Mais on va gagner quoi~? Juste trouver les erreurs aux runtimes…
%%% Même si on couvre tous le code (parler de la couverture~!)
%%%     qui nous dit que le programme fait la bonne chose~?
%%%
%%% Il faut mélanger les spéc/contrats avec ses techniques de génération de
%%% données.
%%%
%%% Parler du Search-based Testing~?
%%% Parler du random (trouver des réf', voir ICTSS'11 peut-être).



UDITA nous permet de faire la transition de la technique boîte-noire vers
boîte-blanche. C'est~à~dire que nous allons nous éloigner de la spécification
pour nous rapprocher du code. D'autres travaux ont été réalisés afin de générer
des données de test, soit avec des techniques statiques, dynamiques ou hybrides.

\paragraph{EXE} \inenglish{EXecution generated Executions}, abbrégé
EXE~\acite{CadarGPDE06, CadarGPDE08}, est un outil d'exécution symbolique pour
programmes C.  Au lieu d'exécuter le programme avec des valeurs construites
manuellement ou aléatoirement, EXE va exécuter le programme, préalablement
instrumenté, de manière symbolique. Durant cette exécution symbolique, EXE va
analyser et indexer toutes les contraintes sur les entrées symboliques (comme
les paramètres des fonctions) et ainsi calculer tous les chemins possibles dans
le programme.  Si EXE rencontre une instruction contenant une valeur symbolique,
alors il va analyser son environnement et générer de nouvelles contraintes.
Quand des embranchements sont rencontrés (comme une condition par exemple), EXE
va dupliquer les exécutions et les contraindre à emprunter chaque chemin de
l'embranchement (pour une condition, ce sera un chemin à vrai et un à faux).
Quand EXE arrive à la fin d'un chemin ou qu'il trouve une erreur, alors il va
automatiquement générer des données de tests à partir des contraintes récoltées.
EXE est accompagné de STP~\acite{GaneshD07}, un solveur de constraintes maison
conçu à l'origine pour EXE. C'est grâce à ce solveur que les valeurs vont être
concrétisées et utilisées comme données de tests sur le programme
non-instrumenté. Les mêmes chemins seront empruntés et les mêmes erreurs seront
trouvées, mais avec des valeurs concrètes, donc exploitables par le développeur.

\paragraph{DART} \inenglish{Directed Automated Random Testing}, abbrégé
DART~\acite{GodefroidKS05}, est également un outil de génération de données de
test à partir de l'analyse du programme. DART opère en trois étapes. Il
commence par extraire les interfaces du programme pour connaître ses
entrées. Ensuite il va générer aléatoirement des données pour ses entrées, et
l'exécuter. Et enfin, il analyse le comportement du programme pendant son
exécution pour détecter quels sont les chemins ou zones qui n'ont pas été
atteints. Cette analyse va permettre de guider la génération des nouvelles
entrées pour la prochaine exécution.

DART et EXE ont une approche similaire pour l'analyse des chemins. À chaque
embranchement du programme, DART va extraire des contraintes symboliques. Pour
générer les données de tests suivantes, il prendra la négation des contraintes
une par une, générer de nouvelles valeurs et le processus continue. Toutefois,
DART ne sait gérer que les contraintes sur les entiers alors qu'EXE sait gérer
des contraintes sur les entiers, les tableaux, les vecteurs de bits, le
transtypage, les opérations arithmétiques etc.

\paragraph{KLEE} L'outil KLEE~\acite{CadarDE08} est la suite d'EXE. Ses auteurs
font le constat suivant~: malgré le fait que les travaux sur l'exécution
symbolique sont encourageants, les outils ne sont toujours pas capables de
passer à l'échelle. En effet, le nombre de chemins dans les programmes sont
exponentiels, et les techniques d'exécutions symboliques n'arrivent plus à
résoudre toutes les contraintes générées. De même, l'exécution symbolique ne
prenait pas en compte l'environnement du programme, comme l'OS, le réseau ou
l'utilisateur. Ce sont ces deux problèmes qu'adresse KLEE grâce à de la
réduction et simplifications de contraintes, des améliorations sur l'exploration
des chemins et des optimisations de la réprésentation de l'environnement.

KLEE utilise toujours STP comme solveur de contraintes.

\paragraph{CUTE} \acite{SenMA05}

\paragraph{Pex} \acite{HalleuxT08}

\paragraph{ARTOO} foo \\

Nous voyons qu'il existe de nombreuses techniques avancées pour la génération de
données de test à partir d'exécution symbolique. Toutefois, si nous repensons
aux contrats et que nous prenons du recul, nous remarquons que l'exécution
symbolique ne permet pas de vérifier qu'un programme fait bien ce que nous
souhaitons. Les erreurs à l'exécution (comme des pointeurs nuls, des
dépassements de tableaux, de tampons etc.) seront détectées, mais rien ne nous
assure que le programme est correct par rapport à une spécification. Nous
retombons sur nos interrogations de la pertinence des tests~: la couverture de
code~\acite{MillerM63, Myers04} à elle seule n'est pas suffisante.

%%% Il faut mélanger les spéc/contrats avec ses techniques de génération de
%%% données.
%%%
%%% Parler du Search-based Testing~?
%%% Parler du random (trouver des réf', voir ICTSS'11 peut-être).



\vspace{5em}

%Un contrat spécifie les données manipulées par un programme. Les programmes
%manipulent deux catégories de données~: scalaires, comme les booléens, les
%entiers, les réels, les chaînes de caractères, et structurelles, comme des
%tableaux ou des objets.
%
%% dire rapidement ce que JML, ACSL etc. utilisent pour générer des données.
%% montrer les limitations.
%%    -> on est loin des préoccupations/domaines des "vrais" dév' et surtout du
%%       web
%% montrer ce qu'il se fait **en dehors** des contrats pour générer des données
%% dire que ce serait super d'avoir ça dans les contrats
%% mais comment le spécifier dans les contrats~? est-ce qu'on seulement on peut~?
%
%Voyons ce qu'il se fait ailleurs.
%
%\subsection{Génération de nombres}
%
%\subsection{Génération de chaînes de caractères}
%
%\paragraph{Yagg}
%
%\paragraph{Geno}
%
%\paragraph{YouGen}
%
%\paragraph{Apollo}
%
%\paragraph{@Flajolet}
%
%\paragraph{@Howden}
%
%+/- conclure avec @Hennessy.
%
%\subsection{Génération de structures}
%
%\paragraph{Euclide}
%
%\paragraph{InKA}
%
%\paragraph{FDCC}
%
%\paragraph{AutoTest}

\section{Génération de tests}

\paragraph{Jartege} L'outil Jartege~\acite{Oriat05} est un générateur de tests
aléatoires pour des programmes écrits en Java. Jartege sélectionne aléatoirement
des méthodes à exécuter. Chaque méthode est annoté par un contrat JML. Les
valeurs des paramètres de ces méthodes sont également générer aléatoirement à
partir de la précondition. Cette dernière sert également de filtre pour
sélectionner les méthodes à exécuter. Les contrats sont également utilisés pour
connaître la conformité du programme par rapport aux postconditions. La
vérifications des contraintes est ainsi conjointe à la création des séquences de
test.

Jartege produit des séquences de test d'une certaine taille et un nombre de
séquences, fixés par l'utilisateur. Par ailleurs, Jartege permet à l'utilisateur
de fournir une fonction qui détermine la probabilité de créer un nouvel objet ou
d'en réutiliser un déjà existant. Selon les structures de données manipulées,
cette fonction permettra de détecter plus ou moins d'erreurs.

\paragraph{Symstra}

\section{Synthèse}

Nous voyons que tout ça est éparpillé.

Nous avons choisi de créer un nouveau langage de spécification plutôt que de
reprendre et améliorer un langage existant.
%Une des raisons est la complexité des autres langages par rapport au niveau des
%ingénieurs de tests. Nous voulions un langage simple, abordable et pragmatique.
La raison principale est qu'il n'existe pas de langage de spécification unifiant
plusieurs théories de l'état de l'art. Plusieurs langages ont permis à des
théories intéressantes d'émerger, mais malheureusement, ces théories sont
trop souvent éparpillées, et donc inutilisables par un ingénieur de test car la
chaîne de développement deviendrait trop complexe.


%
%  Langage de spéc' :
%  
%      V&V
%          verification: are we building the product right?
%          validation: are we building the right product?
%  
%      Model-based Testing
%          super mais trop dur à faire
%  
%      Design-by-Contract
%          Eiffel
%              on explique les pré-, postconditions, invariants.
%  
%      Contract-based Testing
%          du MBT dans le code finalement
%          plus simple
%          plus rapide
%          on est au niveau unitaire du coup (proche du code)
%          on est au niveau black-box du coup
%              sauf si on annote des tests (tests paramétrés, tests fonctionnels…)
%  
%      Ça nous paraît être le bon endroit pour écrire une spéc' (annotation du
%      code), simple pour les développeurs, ça rentre dans les méthodes de dév'
%      etc.
%  
%      JML
%      Spec#
%      ACSL
%  
%      Bilan**
%  
%  
%  Génération de données :
%  
%      Une spécification décrit le fonctionnement du programme. Avec le
%      design-by-contract, on décrit les données.
%  
%      Deux approches :
%          validation : on va valider les données fournies
%          vérification : on va générer puis valider ses données
%  
%      Comment fait-on en général ?
%          Solveur ou autre/aléatoire
%          PHP manipule beaucoup les types suivants :
%              Entiers
%              Tableaux
%              Chaînes/grammaires
%              Objets
%  
%      Bilan**
%  
%  
%  Génération automatique de tests :
%  
%      On fait du contract-based testing
%      On prend une spéc', on génère des séquences d'exécution (des tests), avec
%      les données précédemment générées
%  
%      Comment générer des tests à partir d'une spéc' ?
%      Que cherche-t-on à atteindre ?
%      => couvrir tous les comportements de la spéc', since elle représente/reflète
%      le comportement du programme
%  
%      Qui a fait ça avant ?
%  
%      Bilan**
%  
%  
%  Synthèse
%  
%  
%  
%  
%  
%  Les outils à étudier :
%      Apollo (Sosym)
%   x  JML
%   x  JSConTest
%   x  Eiffel
%      Madsen
%   x  Yagg
%   x  Geno
%   x  YouGen
%   x  @Flajolet
%   x  @Howden
%   x  @Hennessy "Analysing the effectiveness of rule-coverage as a reduction…"
%   x  Korat
%   x  TestEra (pré-Korat)
%   x  UDITA (post-Korat)
%      Java PathFinder
%      Alloy
%      SpecExplorer
%   x  Spec#
%   x  ACSL
%      AsmL
%   x  KLEE
%   x  Exe
%      Symstra
%   x  Jartege
%   x  Euclide
%   x  InKA
%   x  FDCC
%   x  ARTOO
%   x  AutoTest
%   x  Pex
%      Quickcheck
%      JML-Testing-Tools
