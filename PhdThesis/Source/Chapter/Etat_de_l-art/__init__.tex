\chapter{État de l'art}
\label{chapter:state}

\minitoc

Les travaux présentés dans cette thèse sont liés à des activités relatives à la
validation et à la vérification de programmes PHP à travers un nouveau langage
de spécification accompagné de ses outils. Ces activités s'articulent autour de
trois axes majeurs~: langage de spécification, génération de données et
génération automatique de tests.

Informellement, nous pouvons voir un test comme étant composé de trois parties~:

\begin{enumerate}

\item un Système Sous Test (\inenglish{System Under Test}, abbrégé SUT)~;

\item des données pour exécuter ce SUT~;

\item un oracle, capable de nous calculer le verdict du test~: est-ce l'état
du SUT après son exécution est celui attendu ou non~?

\end{enumerate}

Aujourd'hui, dans le monde industriel, la majorité des tests sont écrits
manuellement, par des ingénieurs de test. Un SUT leur est fourni, ils
l'exécutent avec des données et calculent eux-même le verdict du test. Dans le
cas des tests automatisés, l'exécution et le calcul du verdict est fait par la
machine. C'est le rôle qui incombe aux frameworks xUnit, comme
JUnit~\acite{JUnit} pour Java, atoum~\acite{atoum} ou PHPUnit~\acite{PHPUnit}
pour PHP, CUnit~\acite{CUnit} pour C etc. Ce que font les ingénieurs de test
peut se résumer à écrire une spécification informelle exécutable. En effet, ils
transforment le cahier des charges en tests afin de vérifier et valider le
programme.

Toutefois, cela reste informelle. Et surtout, c'est une tâche laborieuse qui
peut revenir cher \footnote{TODO, environ la moitié du prix d'un projet}. Et
pourquoi ne pas écrire une spécification formelle, et la rendre exécutable~?
C'est~à~dire d'utiliser un langage formelle pour décrire le fonctionnement du
programme, puis dériver, à partir de cette spécification, des tests qui soient
exécutables et qui vont vérifier ou valider plusieurs aspects de cette
spécification.

Nous nous intéressons à des programmes écrits en PHP~\acite{PHP} pour plusieurs
raisons. D'une part, PHP est un langage non-typé, hautement dynamique et
multi-paradigme, ce qui nous apporte des problématiques encore peu ou pas abordé
dans l'état de l'art actuel.  De plus, aucun travaux ne considère PHP pour la
génération de données ou la génération de tests. De même, aucun langage de
spécification dédié à PHP n'existait avant les travaux de cette thèse. Par
ailleurs, plus de 85\% du Web fonctionne avec PHP. Cela implique qu'il y a un
marché important avec d'immenses besoins~; que ce soit des sites de
commerces\footnote{Etsy, \url{https://etsy.com/}.}, de banques, d'assurances, de
réseaux sociaux\footnote{Facebook, \url{https://facebook.com/}}, de moteurs de
recherche\footnote{Yahoo, \url{https://yahoo.com/}},
d'encyclopédie\footnote{Wikipedia, \url{https://wikipedia.org/}},
gouvernementaux\footnote{France, Belgique, Suisse, USA, Canada etc.} et
d'autres.

Cette thèse s'intéresse à la conformité entre un programme et sa spécification,
à travers la création d'un nouveau langage de spécification simple, pradgmatique
pour le Web et unifiant plusieurs théories. Chaque théorie introduit se verra
enrichie pour la rendre compatible avec le Web.

\section{\inenglish{Behavioral Interface Specification Languages}}

Le terme {\strong spécification} signifie généralement une description précise
d'un comportement d'un artéfact. La {\strong vérification} signifie prouver
qu'une implémentation (c'est~à~dire un programme) satisfait une spécification
particulière dans toutes les exécutions et configurations possibles.
Généralement, une telle preuve est accomplie à l'aide de raisonnements statiques.
Cette approche a des limites…
%mais il est possible de combiner un raisonnement statique avec une approche
%dynamiques (comme le \inenglish{runtime assertion checking})~\acite{Geller76}.

Un {\strong langage de spécification} formelle est une notation mathématiquement
précise pour décrire les comportements et propriétés d'un programme. Les
{\strong notations formelles} aident à rendre les spécifications non-ambiguës,
moins dépendantes des normes culturelles, et ainsi moins sujettes à une mauvaise
interprétation. Par ailleurs, de part le fait qu'une notation est formelle, elle
peut être exploitée par une machine pour y appliquer un traitement automatique.
Les spécifications formelles peuvent alors aider à {\strong automatiser le
test}, autant pour générer les données de test~\acite{BernotGM91, KorelA98,
SankarH94, Jalote92} que pour calculer le verdict du test~\acite{CheonL02}.
C'est dans ces deux directions que nous allons nous tourner.

Les spécifications peuvent documenter les {\strong interfaces} d'un programme.
Par interfaces, il faut comprendre les parties du programme permettant de
manipuler les données. Nous parlons alors de {\strong langages d'annotations}.
De tels langages peuvent jouer un rôle central dans la programmation. Par
exemple, ils facilitent la maintenance du code, qui n'est généralement pas
suffisament expressif pour faire comprendre au développeur ses tenants et ses
aboutissants. Par ailleurs, lors d'une phase de \inenglish{debugging}, les
annotations permettent de localiser plus facilement la faute. Les annotations
font parfois parties de la grammaire du langage, ou alors, le cas échéant, elles
sont écrites dans des {\strong commentaires}.

Les spécifications sont souvent utilisées sous la forme de {\strong
contrats}~\acite{Liskov86, Meyer92}. Nous parlons de programmations par contrats
ou encore de \inenglish{Design by Contract} (abbrégé DbC). Le terme {\em
contrat} est une métaphore conceptuelle avec les conditions et les obligations
d'un contrat d'entreprise. Ce paradigme demande au développeur d'écrire une
spécification formelle qui étend la définition classique des types
abstraits~\acite{LiskovZ74} avec les contraintes formelles suivantes~: les
{\strong préconditions}, les {\strong postconditions} et les {\strong
invariants}. Ces contraintes formelles sont aussi appelées des {\strong
clauses}. Les contrats sont apparus dans le langage Eiffel~\acite{MeyerNM87},
qui alors se basait sur le paradigme de la programmation orienté objet. Dans un
tel contexte, les préconditions et postconditions portaient sur les méthodes
(aussi appelées procédures ou routines) et les invariants sur les classes (aussi
appelés modules). D'autres usages des contrats ont été faits hors du paradigme
de la programmation orienté objet, par exemple avec des fonctions d'ordre
supérieures~\acite{FindlerF02}.  Le \inenglish{Design by Contract} définit les
critères de conformité suivants~:

\begin{itemize}

\item si les invariants et la précondition de la méthode sont satisfaits avant
son appel,

\item alors la méthode s'engage à satisfaire les invariants et sa postcondition
après son exécution.

\end{itemize}

Les langages décrivant une spécification formelle à travers des contrats pour
le comportement des programmes, mais qui sont utilisés comme annotations, sont
appelés des {\strong langages de contrats}. Il existe
plusieurs~\acite{HatcliffLLMP12}~:

\paragraph{JML} Le \inenglish{Java Modeling Language}~\acite{JML} est un langage
de contrats pour Java~\acite{Java}. La distribuion officielle de JML fournit
principalement deux outils~: le premier, le \inenglish{Runtime Assertion
Checker}, sert de \inenglish{monitoring} au code Java, et le second, JMLUnit,
s'appuyant sur le précédent, est dédié à l'intégration de JML dans le test
unitaire de méthodes Java.

Le RAC de JML~\acite{Cheon02} est un outil permettant de vérifier les contrats
JML lors de l'exécution du programme. Les contrats sont traduits en code Java.
La proximité entre ces deux langages est la clé de la démarche. En effet, la
syntaxe des contrats JML est similaire à celle de Java, et les mots-clés JML
spécifiques (pour par exemple les clauses, les quantificateurs etc.) sont
traduits par des structures Java adéquates.  Néanmoins, cette similitude a des
limites~: certaines constructions du langage, cmomme les quantifications sur les
objets, ne sont pas traduisibles et donc ne peuvent pas être vérifiées. Le code
Java d'origine est ainsi enrichi par la vérification des contrats JML. Le
binaire résultant est plus important, ce qui engendre des ralentissements à
l'exécution du programme. Toutefois, durant son exécution, si une contrainte
n'est pas vérifiée, une exception spécifique est déclenchée signalant le type de
clause qui n'a pas été vérifiée (invariant, précondition etc.) ainsi que l'état
visibile du système au moment de l'exécution.

L'utilisation du RAC confère un moyen direct et efficace de s'assurer que les
contrats JML ne sont pas violés durant une exécution avec les données de
l'exécution.

\paragraph{Spec\#} Langage Spec\#~\acite{SpecSharp} permet de faire de la
programmation par contrat pour C\#~\acite{CSharp}

\paragraph{ACSL} Le \inenglish{ANSI/C Specification Language}~\acite{ACSL} est
un langage de contrats pour C~\acite{C}.

L'un des intérêts et usages principaux des contrats est pour le test. En effet,
le {\strong test à partir de contrat} (\inenglish{Contract-Based Testing},
abbrégé CBT) a été introduit pour exploiter les langages d'annotations afin de
tester des programmes~:

\begin{itemize}

\item les invariants et les préconditions sont utilisées pour générer des
données de tests~;

\item les postconditions fournissent un oracle (partiel) capable de calculer le
verdict du test à l'exécution.

\end{itemize}

Le test est un {\strong succès} si aucune clause n'est violée, sinon le test est
un {\strong échec}.

% là on enchaîne avec les annotations (car on parlait de spéc' qui document le
% code)
% ensuite, on enchaîne sur le Design by Contract
% on s'attarde sur ce qu'est un contrat
% puis, on enchaîne avec le Contract-based Testing
% il faut enfoncer le clou (réfléchir à TAROT)


% …

Cependant, la vérification dynamique souffre de deux limitations. Premièrement,
elle consomme des cycles qui pourraient mieux être utilisés. Plus sérieusement,
la vérification dynamique fournit seulement une couverture limité~: les
spécifications sont souvent vérifiées avec les données des exécutions courantes.
Ainsi, la vérification dynamique résulte souvent à une détection incomplète et
tardive (potentiellement en production) de défauts. Une façon de pallier à cette
limitation est soit d'utiliser une approche hybrique~\acite{Flanagan06}, soit de
générer des données pertinentes pour tenter de couvrir tous les comportements de
la spécification.

\section{Génération de données de tests}

\section{Génération de tests}

\section{Synthèse}

Nous avons choisi de créer un nouveau langage de spécification plutôt que de
reprendre et améliorer un langage existant.
%Une des raisons est la complexité des autres langages par rapport au niveau des
%ingénieurs de tests. Nous voulions un langage simple, abordable et pragmatique.
La raison principale est qu'il n'existe pas de langage de spécification unifiant
plusieurs théories de l'état de l'art. Plusieurs langages ont permis à des
théories intéressantes d'émerger, mais malheureusement, ces théories sont
trop souvent éparpillées, et donc inutilisables par un ingénieur de test car la
chaîne de développement deviendrait trop complexe.


%  Intro :
%      qu'est-ce qu'un test ?
%      tester manuellement :
%          un humain qui écrit des tests
%          long
%          cher
%          faillible
%      un test manuel = une spéc' informelle mais exécutable
%      idée : avoir une spéc' formelle exécutable
%          ça veut dire quoi ?
%          générer des tests à partir de cette spéc'
%  
%      pourquoi PHP ?
%          power 85\% of the Web
%          utiliser partout (banque, social, marché, média…)
%          y avait aucun outil/langage de test non-manuel
%          champs libre pour un nouveau langage de spéc'
%  
%      pourquoi ne pas reprendre un langage existant et l'adapter ?
%          PHP est hautement dynamique, nouvelles problématiques (lesquelles ?)
%          il manque un langage qui unifie les théories
%              beaucoup de théories intéressantes
%              mais éparpillées
%  
%      objectifs de cette thèse :
%          qu'est-ce que l'on cherche à faire ?
%              nous nous intéressons à la conformité entre le programme et sa
%              spécification
%  
%          pour y arriver :
%              faire un nouveau langage de spéc' simple, unifiant plusieurs théories
%              améliorer chaque théorie introduite pour la rendre « compatible »
%              avec le Web
%  
%              à partir duquel nous allons faire de la validation et de la vérification
%              ça implique
%                  d'une part, de générer des données
%                  d'autre part, de générer des tests
%  
%  
%  Langage de spéc' :
%  
%      V&V
%          verification: are we building the product right?
%          validation: are we building the right product?
%  
%      Model-based Testing
%          super mais trop dur à faire
%  
%      Design-by-Contract
%          Eiffel
%              on explique les pré-, postconditions, invariants.
%  
%      Contract-based Testing
%          du MBT dans le code finalement
%          plus simple
%          plus rapide
%          on est au niveau unitaire du coup (proche du code)
%          on est au niveau black-box du coup
%              sauf si on annote des tests (tests paramétrés, tests fonctionnels…)
%  
%      Ça nous paraît être le bon endroit pour écrire une spéc' (annotation du
%      code), simple pour les développeurs, ça rentre dans les méthodes de dév'
%      etc.
%  
%      JML
%      Spec#
%      ACSL
%  
%      Bilan**
%  
%  
%  Génération de données :
%  
%      Une spécification décrit le fonctionnement du programme. Avec le
%      design-by-contract, on décrit les données.
%  
%      Deux approches :
%          validation : on va valider les données fournies
%          vérification : on va générer puis valider ses données
%  
%      Comment fait-on en général ?
%          Solveur ou autre/aléatoire
%          PHP manipule beaucoup les types suivants :
%              Entiers
%              Tableaux
%              Chaînes/grammaires
%              Objets
%  
%      Bilan**
%  
%  
%  Génération automatique de tests :
%  
%      On fait du contract-based testing
%      On prend une spéc', on génère des séquences d'exécution (des tests), avec
%      les données précédemment générées
%  
%      Comment générer des tests à partir d'une spéc' ?
%      Que cherche-t-on à atteindre ?
%      => couvrir tous les comportements de la spéc', since elle représente/reflète
%      le comportement du programme
%  
%      Qui a fait ça avant ?
%  
%      Bilan**
%  
%  
%  Synthèse
%  
%  
%  
%  
%  
%  Les outils à étudier :
%      Apollo (Sosym)
%   x  JML
%      JSConTest
%   x  Eiffel
%      Madsen
%      Yagg
%      Geno
%      YouGen
%      @Flajolet
%      @Howden
%      @Hennessy "Analysing the effectiveness of rule-coverage as a reduction…"
%      Korat
%      TestEra (pré-Korat)
%      UDITA (post-Korat)
%      Java PathFinder
%      Alloy
%      SpecExplorer
%   x  Spec#
%   x  ACSL
%      AsmL
%      Cute
%      Kleen (?)
%      Exe
%      Symstra
%      Jartege
%      Euclide
%      InKA
%      FDCC
%      ARTOO
%      AutoTest
%      Pex
%      Quickcheck
