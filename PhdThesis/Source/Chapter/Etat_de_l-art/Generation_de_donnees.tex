\section{Génération de données}
\label{section:sota:data_generation}

La manière dont Praspel, notre contribution, spécifie les données se situe entre
JSConTest et JML. Nous exprimons beaucoup plus que les types usuels mais nous
n'exprimons pas des contraintes sous forme logique. Nous sommes alors
intéressés par la génération (et validation) de données au sens large. Cette
section va s'intéresser aux travaux concernant la génération de chaînes de
caractères ainsi que de tableaux, qui sont des types très utilisés au sein de
programmes Web.

\paragraph{Génération aléatoire} Beaucoup de travaux et d'outils considèrent la
génération de données aléatoires comme efficace. Elle permet de très rapidement
explorer un modèle, une spécification ou une structure de code à moindre coût.
Le \inenglish{fuzzing}~\acite{GodefroidLM12}, par exemple, est une technique
s'appuyant sur ces deux aspects~: beaucoup de données générées différentes très
rapidement, qui permettent d'éprouver le programme. Malgré ses limitations
évidentes (un test d'égalité entre deux entiers générés aléatoirement a une
probabilité très faible d'être validé), la génération aléatoire est souvent un
moyen de «~déblayer le terrain~» et de répérer les points non triviaux à tester
du programme. C'est pourquoi plusieurs outils considèrent une approche hybride~:
utiliser de l'aléatoire pour éliminer les cas triviaux et éviter l'utilisation
systématique de techniques de résolutions plus gourmandes. D'autres techniques
vont guider l'aléatoire afin de conserver un certain degré de non-déterminisme
tout en respectant par exemple des critères de couverture.

\paragraph{Génération de chaînes de caractères} Les chaînes de caractères sont
intensivement utilisées dans des programmes Web.  Leurs formes sont très
différentes, cela va d'une adresse email à des langages comme XML ou JSON, en
passant par des requêtes SQL etc. La façon la plus répandue dans l'industrie
pour représenter une donnée textuelle est d'utiliser une expression régulière ou
une grammaire algébrique, soit d'une manière générale, une
grammaire~\acite{Chomsky56}. Une grammaire est exprimée à partir d'un {\strong
langage de description} qui déclare des {\strong lexèmes}, unités lexicales
atomiques d'un langage, et des {\strong règles} exprimant l'enchaînement
possible des lexèmes les uns par rapport aux autres.

L'idée commune que nous retrouvons dans la majorité des travaux est d'explorer
ces règles afin de générer une {\strong séquence de lexèmes} qui représente une
donnée valide. Quand les grammaires sont utilisées pour représenter des données
de tests, alors nous parlons de \inenglish{Grammar-based Testing}, abbrégé GbT.

\inenglish{yet another generator-generator}, abbrégé yagg~\acite{CoppitL05} est
un outil de génération de données textuelles complexes à partir d'une grammaire
décrite avec une syntaxe très similaire à LEX~\acite{Lesk75} et
YACC~\acite{Johnson75}, des outils d'analyses syntaxique et lexicale très
largement utilisés. Ce choix de syntaxe est montré comme plus attractif et plus
efficace pour les utilisateurs comparé à TestEra a besoin équivalent. Quand est
traité le problème de générations de données structurelles complexes, notamment
avec des grammaires, la question de la combinatoire se pose forcément. Certains
opérateurs de répétitions de séquences de lexèmes, comme \code{+} (une ou
plusieurs fois) ou \code{*} (zéro ou plusieurs fois) n'ont pas de bornes
supérieures. Afin d'éviter la génération d'énormes données ou de données
explosives, yagg propose de borner ces opérateurs. D'autant plus que yagg a une
approche exhaustive, c'est~à~dire qu'il va énumérer toutes les séquences
possibles de lexèmes.  Les lexèmes sont exprimés avec un sous-langage des
expressions régulières qui ajoute des constructions comme l'alternance
équivalente ou des générateurs d'équivalence.  Ce choix sert également à borner
les valeurs possibles des lexèmes.

L'outil Geno~\acite{LammelS06} propose une solution au problème de l'explosion
combinatoire. Certains travaux proposent des critères de couverture sur les
grammaires. D'autres proposent d'annoter des grammaires avec par exemple des
poids probabilistes afin de guider l'exploration de la grammaire. Geno propose à
l'utilisateur d'annoter une grammaire avec des mots-clés afin de guider la
génération. Ces mots-clés sont une abstraction de choix probabilistes, {\em a
priori} plus simples et concrets. Ces mots-clés sont traités de façon à
conserver une certaine exhaustivité dans les résultats. Similairement, l'outil
YouGen~\acite{HoffmanLSW11} propose à l'utilisateur d'ajouter des
\inenglish{tags} pour borner l'exploration de plusieurs règles en appliquant des
réductions \inenglish{pair-wises}.

La plupart des techniques ayant une approche aléatoire ou exhaustive bornée se
basent respectivement sur les travaux de \acitei{FlajoletZC94} et
\acitei{Howden86}. La démarche est très souvent similaire~: à partir d'une
grammaire, nous sommes capable de générer une données. Mais des annotations sont
ajoutées pour guider cette génération afin d'obtenir des données plus réalistes
selon le contexte d'utilisation. Ces outils demandent toujours une intervention
du développeur mais ces interventions tendent à devenir de plus en plus simples.

\paragraph{Génération de structures} Les structures, comme les tableaux, sont
aussi très utilisés dans le Web pour représenter toutes sortes de collections ou
organiser de manière structurelles des informations. Dans la même lignée que
TestEra, CUTE ou encore PathCrawler~\acite{WilliamsMMR05}, nous trouvons,
Euclide~\acite{Gotlieb09} qui est outil de test à partir de contraintes
exprimées en ACSL. Euclide mélange trois aspects~: analyse structurelle du code
source du programme, production de contre-exemples et preuve partielle du
programme. L'objectif est de mélanger les techniques pour dépasser la limite de
chacune et ainsi, de générer des données permettant de satisfaire plus de
critères de couverture de code.

{\scshape fdcc}~\acite{BardinG12} est un solveur pour les tableaux avec
contraintes sur des domaines finis. Les auteurs font le constat que les tableaux
sont omniprésents dans les outils de vérifications, mais que des approches
efficaces pour les traiter sont assez rares dans la programmation par
contraintes. Les auteurs proposent alors une approche combinant deux solveurs,
l'un raisonnant de manière symbolique (pour connaître les accès, les écritures
et la taille des tableaux), l'autre manipulant des contraintes sur les domaines
finis. La partie originale et difficile est la communication bi-directionnelle
entre ces deux outils.

Mentionnons aussi l'outil Minion~\acite{GentJM06} qui fait un constat et une
approche similaire à {\scshape fdcc}~: les auteurs préfèrent coupler des
solutions ensemble et les faire communiquer. Les résultats sont très
encourageants~: comme pour {\scshape fdcc}, le solveur converge beaucoup plus
rapidement et est capable de répondre à plus de problèmes. La partie délicate
est toujours de filtrer et transformer les problèmes pour que les différents
solveurs puissent commniquer entre eux.

\paragraph{Génération d'objets} Un objet est un aggrégat de plusieurs données
placées sur des attributs de classe.  Il existe deux approches majeures pour
générer des objets~: soit prendre les attributs un par un et leur générer une
donnée (par exemple avec un invariant de classe si des contrats sont présents),
ou alors d'appeler les méthodes sur une instance d'une classe afin de construire
un objet plus réaliste.

Un exemple de cette seconde approche est l'outil Jartege~\acite{Oriat05}, un
générateur de tests aléatoires pour des programmes écrits en Java. Jartege
sélectionne aléatoirement des méthodes à exécuter.  Chaque méthode est annoté
par un contrat JML. Les valeurs des paramètres de ces méthodes sont également
générer aléatoirement à partir de la précondition. Cette dernière sert également
de filtre pour sélectionner les méthodes à exécuter. Les contrats sont également
utilisés pour connaître la conformité du programme par rapport aux
postconditions. La vérifications des contraintes est ainsi conjointe à la
création des séquences de test.

Jartege produit des séquences de test d'une certaine taille et un nombre de
séquences, fixés par l'utilisateur. Par ailleurs, Jartege permet à l'utilisateur
de fournir une fonction qui détermine la probabilité de créer un nouvel objet ou
d'en réutiliser un déjà existant. Selon les structures de données manipulées,
cette fonction permettra de détecter plus ou moins d'erreurs. \\

Nous voyons que les outils se mélangent de plus en plus afin d'obtenir des
données plus pertinentes et plus rapidement.

\section{Synthèse}

Nous voyons que tout ça est éparpillé.

Nous avons choisi de créer un nouveau langage de spécification plutôt que de
reprendre et améliorer un langage existant.
%Une des raisons est la complexité des autres langages par rapport au niveau des
%ingénieurs de tests. Nous voulions un langage simple, abordable et pragmatique.
La raison principale est qu'il n'existe pas de langage de spécification unifiant
plusieurs théories de l'état de l'art. Plusieurs langages ont permis à des
théories intéressantes d'émerger, mais malheureusement, ces théories sont
trop souvent éparpillées, et donc inutilisables par un ingénieur de test car la
chaîne de développement deviendrait trop complexe.
