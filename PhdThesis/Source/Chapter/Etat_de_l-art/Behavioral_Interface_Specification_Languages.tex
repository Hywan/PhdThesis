\section{\inenglish{Behavioral Interface Specification Languages}}
\label{section:sota:bisl}

Le terme {\strong spécification} signifie généralement une description précise
d'un comportement d'un artéfact. La {\strong vérification} signifie prouver
qu'une implémentation (c'est~à~dire un programme) satisfait une spécification
particulière dans toutes les exécutions et configurations possibles.
Généralement, une telle preuve est accomplie à l'aide de raisonnements
statiques, c'est~à~dire uniquement par analyse du programme. Quand un
raisonnement statique n'est pas possible ou suffisant, nous pouvons utiliser une
{\strong validation} dynamique, pour tester l'implémentation, c'est~à~dire que
nous allons exécuter le programme. Une validation dynamique est aussi appelée
\inenglish{Runtime Assertion Checking}, abrégé RAC~\acite{Geller76}.

Un {\strong langage de spécification} formel est une notation précise pour
décrire les comportements et propriétés d'un programme. Les {\strong notations
formelles} aident à rendre les spécifications non-ambiguës, moins dépendantes
des normes culturelles, et ainsi moins sujettes à une mauvaise interprétation.
Les langages de spécification sont conçus pour répondre à des problèmes généraux
ou spécialisés. Les langages de spécifications généraux, tels que
Z~\acite{Spivey89} ou OCL~\acite{RichtersG98}, ne sont pas conçus pour une
méthodologie particulière ou des outils de vérifications. Cependant, les
langages de spécifications sont très souvent spécialisés, en fonction du type de
langage qu'ils visent~: typage statique et fort, ou dynamique et faible, orienté
objet ou fonctionnel etc.

Par ailleurs, comme une notation est formelle, elle peut être exploitée par une
machine pour y appliquer un traitement automatique.  Les spécifications
formelles peuvent alors aider à {\strong automatiser le test}, autant pour
générer les données de test~\acite{BernotGM91, KorelA98, SankarH94, Jalote92}
que pour calculer le verdict du test~\acite{CheonL02}. C'est dans ces deux
directions que nous allons nous tourner\footnote{TODO: en introduction}.

Les spécifications peuvent documenter les {\strong interfaces} d'un programme.
Par interfaces, il faut comprendre les parties du programme permettant de
manipuler les données. Nous parlons alors de {\strong langages d'annotations}.
De tels langages peuvent jouer un rôle central dans la programmation. Par
exemple, ils facilitent la maintenance du code, qui n'est généralement pas
suffisament expressif pour faire comprendre au développeur ses tenants et ses
aboutissants. Par ailleurs, lors d'une phase de \inenglish{debugging}, les
annotations permettent de localiser plus facilement la faute. Dans le cas où
nous travaillons en boîte-blanche (\inenglish{white-box}), c'est~à~dire où nous
avons accès au code source du programme, les annotations peuvent faire partie
de la grammaire du langage, ou alors, elles sont écrites dans des {\strong
commentaires}. Dans le cas où nous travaillons en boîte-noire
(\inenglish{black-box}), c'est~à~dire où nous n'avons pas ou partiellement
d'accès au code source, les annotations peuvent parfois être externes au
programme, par exemple sur un langage de définition d'interface
(\inenglish{Interface Definition Language}, abrégé IDL) ou sur un modèle, ce qui
nous rapprocherait du \inenglish{Model-based Testing}, abrégé
MbT~\acite{Utting07}. La différence entre boîte-noire et boîte-blanche peut
parfois être plus subtile~\acite{Gaudel11}.  Nous considérons que nous sommes en
boîte-noire quand nous n'exploitons pas la structure du code, basiquement le
contenu des fonctions et méthodes, sinon, nous sommes en boîte-blanche.

\subsection{Langages de contrats}
\label{subsection:sota:dbc}

Les spécifications sont souvent utilisées sous la forme de {\strong
contrats}~\acite{Liskov86, Meyer92}. Nous parlons de programmation par contrats
ou encore de \inenglish{Design by Contract} (abrégé DbC). Le terme {\em contrat}
est une métaphore conceptuelle avec les conditions et les obligations d'un
contrat d'entreprise. Ce paradigme demande au développeur d'écrire une
spécification formelle qui étend la définition classique des types
abstraits~\acite{LiskovZ74} avec les contraintes formelles suivantes~: des
{\strong préconditions}, des {\strong postconditions} et des {\strong
invariants}. Ces contraintes formelles sont aussi appelées des {\strong
clauses}. Il est admis de dire qu'une clause contient des {\strong assertions}.
Les contrats sont apparus dans le langage Eiffel~\acite{MeyerNM87}, qui alors se
basait sur le paradigme de la programmation orienté objet. Dans un tel contexte,
les préconditions et postconditions portaient sur les méthodes (aussi appelées
procédures ou routines) et les invariants sur les classes (aussi appelés
modules). D'autres usages des contrats ont été faits hors du paradigme de la
programmation orienté objet, par exemple avec des fonctions d'ordre
supérieur~\acite{FindlerF02}. Le \inenglish{Design by Contract} définit les
critères de conformité suivants~:

\begin{itemize}

\item si les invariants et la précondition de la méthode sont satisfaits avant
son appel,

\item alors la méthode s'engage à satisfaire les invariants et sa postcondition
après son exécution.

\end{itemize}

Par extension, nous comprenons qu'il existe deux états pour le SUT~: avant
l'exécution d'une méthode, il se trouve dans un {\strong pré-état}, et après
l'exécution d'une méthode, il se trouve dans un {\strong post-état}. Pour les
langages supportant les exceptions, il existe un post-état normal et un
post-état exceptionnel dans le cas où une exception ait été levée. Par ailleurs,
nous disons que le test est un {\strong succès} si aucune clause n'est violée,
sinon le test est un {\strong échec}.

Les langages décrivant une spécification formelle à travers des contrats pour le
comportement des programmes, et utilisés comme annotations, sont appelés des
{\strong langages de contrats}. Il en existe plusieurs~\acite{HatcliffLLMP12}.

\paragraph{JML} Le \inenglish{Java Modeling Language}~\acite{JML} est un langage
de contrats pour Java~\acite{Java}. À la différence de Eiffel qui utilise
\code{require} et \code{ensure}, JML utilise les mots-clés \code{requires} et
\code{ensures} pour introduire les préconditions et les postconditions. Dans
Eiffel, une postcondition exceptionnelle est introduite par le mot-clé
\code{rescue} alors que dans JML, nous avons \code{signals}. Les invariants sont
dans les deux cas introduits par le mot-clé \code{invariant}. JML propose
également des identifiants réservés, comme \aresult, présent uniquement dans une
postcondition normale, et qui fait référence au résultat de la méthode.  De
même, nous trouvons la construction \aold{i}, présente uniquement dans une
postcondition, qui fait référence à la valeur de la données $i$ dans le
pré-état. JML propose également des constructions logiques, comme la relation
d'implication ($\implies$), d'équivalence ($\Longleftrightarrow$) ou des
quantificateurs comme \code{$\bslash$forall} ($\forall$) et
\code{$\bslash$exists} ($\exists$).

La distribution officielle de JML fournit principalement deux outils.  Le
premier, le \inenglish{Runtime Assertion Checker}, sert de
\inenglish{monitoring} au programme Java, et le second, JMLUnit, s'appuyant sur
le précédent, est dédié à Java. Le RAC de JML~\acite{Cheon02} est un outil
permettant de vérifier les contrats JML lors de l'exécution du programme. Les
contrats JML sont traduits en Java~\acite{Raghavan2005}. La proximité entre ces
deux langages est la clé de la démarche. En effet, la syntaxe des contrats JML
est similaire à celle de Java, et les mots-clés JML spécifiques (pour par
exemple les clauses, les quantificateurs etc.) sont traduits par des structures
Java adéquates. Néanmoins, cette similitude a des limites~: certaines
constructions du langage, comme les quantifications sur les objets, ne sont pas
traduisibles et donc ne peuvent pas être vérifiées.

Le programme Java d'origine est ainsi enrichi par la vérification des contrats
JML. Un inconvénient est que le binaire résultant est plus important, ce qui
engendre des ralentissements à l'exécution. En revanche, si une contrainte n'est
pas vérifiée, une exception spécifique est déclenchée signalant le type de
clause qui n'a pas été vérifiée (invariant, précondition etc.) ainsi que l'état
visibile du système au moment de l'exécution. L'utilisation du RAC confère un
moyen direct et efficace de s'assurer que les contrats JML ne sont pas violés
durant une exécution avec les données de l'exécution.

\paragraph{ACSL} Le \inenglish{ANSI/ISO C Specification Language}~\acite{ACSL}
est un langage de contrats pour C~\acite{C}, inspiré principalement du langage
de spécification de l'outil Caduceus~\acite{FilliatreM07}, dédié à la
vérification déductive de propriétés de comportements de programmes C. Caduceus
est lui-même inspiré de JML. Les langages se ressemblent: les mot-clés
\code{requires} et \code{ensures} introduisent respectivement une précondition
et une postcondition. Les invariants sont introduits avec le mot-clé
\code{invariant}.  Plusieurs comportements peuvent être exprimés pour une même
méthode avec le mot-clé \code{behavior}. ACSL propose d'autres clauses pour
exprimer des lemmes, des axiomes ou des fonctions logiques.

Contrairement à JML qui utilise Java pour exprimer ces contraintes, ACSL
n'utilise pas de C mais un langage plus simple, qui s'inspire toutefois de C
(pour les opérateurs arithmétiques, logiques, les tableaux etc.) afin de ne pas
perturber l'utilisateur. D'autres contraintes sont présentes car intrinsèques au
langage, comme la logique des pointeurs, et d'autres ne sont pas présentes,
comme les exceptions.

Les outils d'ACSL sont basés sur le \inenglish{Framework for Modular Analyses of
C}, abrégé Frama-C~\acite{FramaC}. Ce dernier propose plusieurs analyses de
programmes C. Les outils d'ACSL l'utilisent pour de la vérification statique.
C'est la grande différence avec JML, qui lui repose sur un RAC, donc une
vérification à l'exécution, ce que ne fait pas ACSL. Des extensions à Frama-C
peuvent être installées pour permettre à des outils externes, comme des
assistants de preuve interactifs ou des prouveurs automatiques de théorèmes,
d'aider à la vérification de certaines spécifications.

\paragraph{Spec\#} Le langage Spec\#~\acite{SpecSharp} permet de faire de la
programmation par contrat pour C\#~\acite{CSharp}. Ce langage est très similaire
à ACSL, avec toutefois moins de clauses. Les préconditions sont introduites avec
le mot-clé \code{requires}, les postconditions avec le mot-clé \code{ensures}.
De même, les invariants sont introduits avec le mot-clé \code{invariant}. En
plus des quantificateurs \code{forall}, \code{exists} et \code{exists unique},
Spec\# propose \code{sum}, \code{product}, \code{min} etc. Les contraintes sont
exprimées avec un langage proche de C\#, toujours pour ne pas perturber
l'utilisateur, mais toutes les constructions de C\# ne sont pas présentes,
seulement un sous-ensemble.  Par ailleurs, Spec\# enrichit le langage C\# en lui
ajoutant des constructions permettant de vérifier l'absence ou la possible
présence de valeurs nulles (avec \code{!} ou \code{?}).

Tout comme ACSL, la vérification des contrats se fait statiquement, et non pas
dynamiquement via un RAC. Et contrairement à JML où les contrats sont
transformés en Java, ici ils sont transformés en Boogie~\acite{BarnettCDJL05},
un langage intermédiaire pour encoder des conditions de vérification pour les
langages impératifs et orientés objets. Boogie s'appuye sur des solveurs
externes, notamment Z3~\acite{DeMoura2008}, pour vérifier les contrats. \\

Se distinguent deux grandes familles de vérification de contrats~: statique, à
l'aide de prouveurs maisons et externes, ou dynamique, à l'aide d'un RAC. \\

Presque chaque langage de programmation répandu a son propre langage de
contrats. Cette approche est en général bien acceptée par les développeurs car
elle est proche du code source du programme. Toutefois, selon la complexité du
langage de spécification, elle sera plus ou moins utilisée. Cette complexité
ressentie peut être compensée par d'autres services que peuvent offrir les
contrats.

\subsection{Test à partir de contrats}
\label{subsection:sota:cbt}

Jusqu'à maintenant, nous avons vu comment les contrats sont utilisés pour
{\strong filtrer} les données manipuler par un programme ou pour vérifier que le
programme ne produira pas d'erreur. Cependant, l'un des intérêts et usages
principaux des contrats est pour le {\strong test}. En effet, le {\strong test à
partir de contrats} (\inenglish{Contract-based Testing}, abrégé CbT) a été
introduit pour exploiter les langages de contrats afin de tester des
programmes~\acite{Aichernig03}~:

\begin{itemize}

\item les invariants et les préconditions sont utilisés pour {\strong générer
des données} de test~;

\item les postconditions {\strong fournissent un oracle} capable de calculer le
verdict du test à l'exécution.

\end{itemize}

Rappelons qu'un test est composé de trois parties~: un SUT, des données de test
et un oracle. La première partie est présente du fait de la proximité entre les
contrats et le programme, et les deux dernières nous sont données en exploitant
le contrat. À partir d'une spécification formelle, sous la forme d'un contrat,
nous sommes capable de générer des tests automatiquement. Comme nous sommes au
niveau du code source du programme, et plus précisément, sur les méthodes des
classes (dans un contexte orienté objet), les tests seront {\strong unitaires}. \\

Le test à partir de contrat répond au constat suivant. La validation dynamique
souffre d'une limitation majeure~: elle fournit des résultats limités. Les
spécifications sont souvent vérifiées avec les données des exécutions courantes
et rarement de manière exhaustive. Ainsi, la validation dynamique résulte
souvent à une détection incomplète et tardive (potentiellement en production) de
défauts. Et pourtant, «~un test montre la présence, jamais l'absence d'une
erreur~» (Edsger W.~Dijkstra dans~\acitep{Buxton70}). Et un bon test est un test
qui échoue.  Pour savoir ce qu'est un «~bon test~», il existe plusieurs
métriques pour le qualifier~: les critères de couverture de
code~\acite{MillerM63, Myers04, GargantiniGM12}. Si plusieurs tests remplissent
les critères les plus élevés de la couverture de code, alors une importante
partie des erreurs serait détectée. Toutefois, il faut être conscient que ces
critères ne sont pas non plus exhaustives. En effet, ce n'est pas parce qu'un
test à activer tous les chemins que toutes les erreurs ont été évitées. De plus,
des erreurs peuvent se cacher dans l'environnement d'exécution du programme.
Notons que si nous travaillons en boîte-noire, ces critères ne sont pas
appliquables, et nous pouvons uniquement nous référer aux postconditions des
contrats.

Une façon de pallier ces limitations est de générer des données de tests les
plus pertinentes possible afin de tenter de couvrir tous les comportements de la
spécification. C'est un des grands défis du test à partir de contrat.
